local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	local hrp = character:WaitForChild("HumanoidRootPart")
	local camera = workspace.CurrentCamera

	local DEFAULT_SPEED = 28
	local BOOSTED_SPEED = 35
	local SPEED_BOOST_DURATION = 0.3
	local SLIDE_SPEED = 32

	humanoid.WalkSpeed = DEFAULT_SPEED

	local holdingT = false
	local sliding = false
	local dead = false
	local wallJumpCooldown = false

	-- Slide Animation (replace with your slide animation ID)
	local slideAnimId = "rbxassetid://YOUR_SLIDE_ANIM_ID" -- CHANGE THIS
	local animSlide = Instance.new("Animation")
	animSlide.AnimationId = slideAnimId
	local animTrackSlide = humanoid:LoadAnimation(animSlide)

	-- Wall jump function
	local function doWallJump()
		if wallJumpCooldown or dead then return end

		local sides = {
			hrp.CFrame.RightVector,
			-hrp.CFrame.RightVector
		}

		local params = RaycastParams.new()
		params.FilterDescendantsInstances = {character}
		params.FilterType = Enum.RaycastFilterType.Blacklist

		for _, dir in ipairs(sides) do
			local hit = workspace:Raycast(hrp.Position, dir * 3, params)
			if hit and hit.Normal.Y < 0.5 then
				local forward = hrp.CFrame.LookVector
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				hrp.Velocity = forward.Unit * 60 + Vector3.new(0, 50, 0)

				humanoid.WalkSpeed = BOOSTED_SPEED
				task.delay(SPEED_BOOST_DURATION, function()
					if not dead then
						humanoid.WalkSpeed = DEFAULT_SPEED
					end
				end)

				wallJumpCooldown = true
				task.delay(0.4, function()
					wallJumpCooldown = false
				end)

				break
			end
		end
	end

	-- Input handlers
	UIS.InputBegan:Connect(function(input, gpe)
		if gpe then return end
		if input.KeyCode == Enum.KeyCode.T and not holdingT then
			holdingT = true
			sliding = true
			animTrackSlide:Play()
			humanoid.WalkSpeed = 0
			humanoid:ChangeState(Enum.HumanoidStateType.Swimming) -- helps slide anim priority
		elseif input.KeyCode == Enum.KeyCode.Space then
			doWallJump()
		end
	end)

	UIS.InputEnded:Connect(function(input)
		if input.KeyCode == Enum.KeyCode.T then
			holdingT = false
			sliding = false
			animTrackSlide:Stop()
			if not dead then
				humanoid.WalkSpeed = DEFAULT_SPEED
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
			end
		end
	end)

	-- Physics + movement update
	RunService.RenderStepped:Connect(function()
		if dead then return end

		if sliding then
			-- Slow momentum loss (drag)
			hrp.Velocity *= 0.99

			-- Downhill speed gain
			local rayParams = RaycastParams.new()
			rayParams.FilterDescendantsInstances = {character}
			rayParams.FilterType = Enum.RaycastFilterType.Blacklist

			local ray = workspace:Raycast(hrp.Position, Vector3.new(0, -5, 0), rayParams)
			if ray then
				local normal = ray.Normal
				if normal:Dot(Vector3.new(0, 1, 0)) < 0.95 then
					local downhill = (Vector3.new(0, -1, 0) - normal).Unit * 0.4
					hrp.Velocity += downhill
				end
			end

			-- Drifting with WASD relative to camera
			local forward = 0
			local right = 0

			if UIS:IsKeyDown(Enum.KeyCode.W) then forward += 1 end
			if UIS:IsKeyDown(Enum.KeyCode.S) then forward -= 1 end
			if UIS:IsKeyDown(Enum.KeyCode.A) then right -= 1 end
			if UIS:IsKeyDown(Enum.KeyCode.D) then right += 1 end

			local camCF = camera.CFrame
			local moveDir = (camCF.LookVector * forward + camCF.RightVector * right)
			if moveDir.Magnitude > 0 then
				moveDir = moveDir.Unit
			end

			local slideVel = Vector3.new(moveDir.X * SLIDE_SPEED, hrp.Velocity.Y, moveDir.Z * SLIDE_SPEED)
			hrp.Velocity = slideVel
		end
	end)

	-- Cleanup on death
	humanoid.Died:Connect(function()
		dead = true
		animTrackSlide:Stop()
		script:Destroy()
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end

player.CharacterAdded:Connect(onCharacterAdded)

player.CharacterAdded:Once(function()
	script:Destroy()
end)
