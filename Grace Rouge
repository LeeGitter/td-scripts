local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local slideAnimationId = 132439703713518
local slideAnimTrack
local animator
local holdingSlide = false

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

local defaultWalkSpeed = 28
local defaultJumpPower = 50
local maxSpeed = 55
local slideMomentum = Vector3.new(0, 0, 0)

local lastJumpTime = 0
local jumpCooldownTime = 0.5

local walljumpSpeedBuffTime = 0.3
local walljumpSpeedBuffAmount = 12

local Camera = workspace.CurrentCamera
local baseFOV = 70
local maxFOV = 90

-- Play slide animation looped
local function playSlideAnim()
    if slideAnimTrack and slideAnimTrack.IsPlaying then return end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. slideAnimationId
    slideAnimTrack = animator:LoadAnimation(anim)
    slideAnimTrack.Looped = true
    slideAnimTrack:Play()
end

local function stopSlideAnim()
    if slideAnimTrack then
        slideAnimTrack:Stop()
        slideAnimTrack = nil
    end
end

-- Check for wall on left or right
local function isWallLeftOrRight()
    local rayLength = 1.5
    local ignoreList = {character}
    local leftRay = Ray.new(hrp.Position, -hrp.CFrame.RightVector * rayLength)
    local rightRay = Ray.new(hrp.Position, hrp.CFrame.RightVector * rayLength)

    local leftHit = workspace:FindPartOnRayWithIgnoreList(leftRay, ignoreList)
    local rightHit = workspace:FindPartOnRayWithIgnoreList(rightRay, ignoreList)

    if leftHit and leftHit.CanCollide then
        return true, -hrp.CFrame.RightVector
    elseif rightHit and rightHit.CanCollide then
        return true, hrp.CFrame.RightVector
    else
        return false, nil
    end
end

-- Try wall jump: push up and forward if near wall on left/right
local function tryWallJump()
    local touchingWall, wallDir = isWallLeftOrRight()
    if not touchingWall then return false end
    if tick() - lastJumpTime < jumpCooldownTime then return false end

    local jumpPower = 50
    local forwardPushPower = 40
    local lookDir = Vector3.new(hrp.CFrame.LookVector.X, 0, hrp.CFrame.LookVector.Z)
    if lookDir.Magnitude == 0 then
        lookDir = Vector3.new(0, 0, -1)
    else
        lookDir = lookDir.Unit
    end

    hrp.Velocity = lookDir * forwardPushPower + Vector3.new(0, jumpPower, 0)

    lastJumpTime = tick()

    maxSpeed = math.min(maxSpeed + walljumpSpeedBuffAmount, 55)
    delay(walljumpSpeedBuffTime, function()
        maxSpeed = 55
    end)

    return true
end

local function applySlideMovement(dt)
    -- WASD input vector (camera relative)
    local inputVec = Vector3.new(0, 0, 0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then inputVec = inputVec + Vector3.new(0, 0, 1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then inputVec = inputVec + Vector3.new(0, 0, -1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then inputVec = inputVec + Vector3.new(-1, 0, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then inputVec = inputVec + Vector3.new(1, 0, 0) end

    if inputVec.Magnitude > 1 then
        inputVec = inputVec.Unit
    end

    local cam = workspace.CurrentCamera
    local camCFrame = cam.CFrame
    local camLook = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z)
    if camLook.Magnitude == 0 then camLook = Vector3.new(0, 0, -1) else camLook = camLook.Unit end
    local camRight = Vector3.new(camCFrame.RightVector.X, 0, camCFrame.RightVector.Z).Unit

    local desiredDir = camRight * inputVec.X + camLook * inputVec.Z
    if desiredDir.Magnitude > 1 then
        desiredDir = desiredDir.Unit
    end

    -- If no input, keep previous momentum direction but decay slowly
    -- If input, gently steer momentum towards desiredDir with inertia

    local steerStrength = 15
    if inputVec.Magnitude > 0 then
        local desiredVel = desiredDir * maxSpeed
        local acceleration = (desiredVel - slideMomentum) * steerStrength * dt
        slideMomentum = slideMomentum + acceleration
    else
        -- No input, slideMomentum slowly decays direction but keeps magnitude (simulate drift)
        local decayRate = 3
        local speed = slideMomentum.Magnitude
        if speed > 0 then
            local newSpeed = math.max(speed - decayRate * dt, 0)
            slideMomentum = slideMomentum.Unit * newSpeed
        end
    end

    -- Slope boost (adds horizontal speed downhill)
    if slideMomentum.Magnitude > 0.1 then
        local forwardDir = slideMomentum.Unit
        local rayOrigin = hrp.Position + forwardDir * 2 + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -5, 0)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        if raycastResult then
            local surfaceNormal = raycastResult.Normal
            local slopeAngle = math.acos(surfaceNormal:Dot(Vector3.new(0, 1, 0)))
            local maxSlopeAngle = math.rad(45)

            if slopeAngle > 0 and slopeAngle <= maxSlopeAngle then
                local downhillDir = Vector3.new(surfaceNormal.X, 0, surfaceNormal.Z).Unit * -1
                local slopeFactor = (maxSlopeAngle - slopeAngle) / maxSlopeAngle
                slideMomentum = slideMomentum + downhillDir * slopeFactor * 15 * dt
            end
        end
    end

    -- Friction (momentum decay)
    local friction = 8
    slideMomentum = slideMomentum * math.clamp(1 - friction * dt, 0, 1)

    -- Clamp speed
    if slideMomentum.Magnitude > maxSpeed then
        slideMomentum = slideMomentum.Unit * maxSpeed
    elseif slideMomentum.Magnitude < 0.1 then
        slideMomentum = Vector3.new(0, 0, 0)
    end

    -- Preserve vertical velocity, apply momentum to horizontal velocity
    local currentYVel = hrp.Velocity.Y
    hrp.Velocity = Vector3.new(slideMomentum.X, currentYVel, slideMomentum.Z)

    -- Lock humanoid movement controls while sliding
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
end

local function onSlideAction(actionName, inputState, inputObj)
    if inputState == Enum.UserInputState.Begin then
        if not holdingSlide then
            holdingSlide = true
            playSlideAnim()
        end
    elseif inputState == Enum.UserInputState.End then
        if holdingSlide then
            holdingSlide = false
            stopSlideAnim()
            slideMomentum = Vector3.new(0, 0, 0)
            humanoid.WalkSpeed = defaultWalkSpeed
            humanoid.JumpPower = defaultJumpPower
        end
    end
end

ContextActionService:BindAction("SlideAction", onSlideAction, false, Enum.KeyCode.Z)

RunService.RenderStepped:Connect(function(dt)
    if holdingSlide then
        applySlideMovement(dt)

        -- Dynamic FOV based on speed
        local speedFraction = slideMomentum.Magnitude / maxSpeed
        speedFraction = math.clamp(speedFraction, 0, 1)

        local targetFOV = baseFOV + (maxFOV - baseFOV) * speedFraction
        Camera.FieldOfView = Camera.FieldOfView + (targetFOV - Camera.FieldOfView) * 5 * dt
    else
        slideMomentum = Vector3.new(0, 0, 0)

        -- Smoothly reset FOV
        Camera.FieldOfView = Camera.FieldOfView + (baseFOV - Camera.FieldOfView) * 5 * dt

        if humanoid.WalkSpeed ~= defaultWalkSpeed then
            humanoid.WalkSpeed = defaultWalkSpeed
        end
        if humanoid.JumpPower ~= defaultJumpPower then
            humanoid.JumpPower = defaultJumpPower
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Space then
        tryWallJump()
    end
end)

local function setupCharacter(char)
    character = char
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")
    animator = humanoid:WaitForChild("Animator")
    holdingSlide = false
    slideMomentum = Vector3.new(0, 0, 0)
    humanoid.WalkSpeed = defaultWalkSpeed
    humanoid.JumpPower = defaultJumpPower
    stopSlideAnim()
end

if player.Character then
    setupCharacter(player.Character)
end
player.CharacterAdded:Connect(setupCharacter)
