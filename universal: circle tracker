local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- Settings
local tailLength = 16
local tailParts = {}
local tailRadius = 0.5
local segmentDistance = 0.6
local idleThreshold = 4
local boredAnimations = {
	function(part)
		part.CFrame *= CFrame.Angles(0.2, 0.2, 0)
	end,
	function(part)
		part.CFrame *= CFrame.Angles(0, 0.2, 0.2)
	end,
	function(part)
		part.CFrame *= CFrame.Angles(math.random(), math.random(), math.random())
	end
}

-- Make tail
local function createTailPart(index)
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Block
	part.Anchored = false
	part.CanCollide = false
	part.Size = Vector3.new(tailRadius, tailRadius, tailRadius)
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromHSV(index / tailLength, 1, 1)
	part.Parent = workspace
	local att = Instance.new("Attachment", part)
	return part, att
end

-- Setup tail
for i = 1, tailLength do
	local part, att = createTailPart(i)
	tailParts[i] = {
		Part = part,
		Attachment = att,
		TargetPosition = root.Position - root.CFrame.LookVector * i * segmentDistance,
		Velocity = Vector3.zero
	}
end

-- Create the white cube (17th part)
local whiteCube = Instance.new("Part")
whiteCube.Size = Vector3.new(1.5, 1.5, 1.5)
whiteCube.Shape = Enum.PartType.Block
whiteCube.Anchored = true
whiteCube.CanCollide = false
whiteCube.Material = Enum.Material.Neon
whiteCube.Color = Color3.new(1, 1, 1)
whiteCube.Parent = workspace

local glow = Instance.new("PointLight", whiteCube)
glow.Brightness = 2
glow.Range = 8

-- Track idle
local lastMoveTime = tick()

-- Update loop
RunService.RenderStepped:Connect(function(dt)
	local currentPosition = root.Position
	local currentLook = root.CFrame.LookVector

	-- Update tail parts
	for i, segment in ipairs(tailParts) do
		local target = (i == 1) and (currentPosition - currentLook * segmentDistance)
			or tailParts[i - 1].Part.Position - (tailParts[i - 1].Part.Position - segment.Part.Position).Unit * segmentDistance

		local direction = target - segment.Part.Position
		segment.Velocity = segment.Velocity * 0.9 + direction * 0.1
		segment.Part.Position += segment.Velocity * dt
		segment.Part.CFrame = CFrame.new(segment.Part.Position, (i == 1 and root.Position or tailParts[i - 1].Part.Position))

		-- Color update
		local h = (i / tailLength + tick() * 0.1) % 1
		segment.Part.Color = Color3.fromHSV(h, 1, 1)
	end

	-- White cube follows last tail part's direction with -5 stud offset
	local tip = tailParts[#tailParts].Part
	local offsetCFrame = tip.CFrame * CFrame.new(0, 0, -5)
	whiteCube.CFrame = offsetCFrame * CFrame.Angles(0, tick(), 0) -- passive spin

	-- Idle detection
	local velocity = root.Velocity.Magnitude
	if velocity > 1 then
		lastMoveTime = tick()
	else
		if tick() - lastMoveTime > idleThreshold then
			local boredFunc = boredAnimations[math.random(1, #boredAnimations)]
			for _, segment in ipairs(tailParts) do
				boredFunc(segment.Part)
			end
		end
	end
end)
