local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- CONFIG
local tailLength = 17
local idleThreshold = 4
local cubeOffset = Vector3.new(0, 0, -10)
local boredAnims = {
	function(part) part.Orientation = part.Orientation + Vector3.new(0, 10, 0) end,
	function(part) part.Orientation = part.Orientation + Vector3.new(5, 0, 5) end,
	function(part) part.Orientation = part.Orientation + Vector3.new(0, -15, 0) end,
}

-- CLEANUP
if character:FindFirstChild("TailModel") then
	character.TailModel:Destroy()
end

-- CREATE TAIL
local tailModel = Instance.new("Model", character)
tailModel.Name = "TailModel"

local prevPart = root
local tailParts = {}

for i = 1, tailLength do
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Block
	part.Anchored = false
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromHSV((i / tailLength), 1, 1)
	local sizeScale = 0.4 + (i / tailLength) * 1.2
	part.Size = Vector3.new(sizeScale, sizeScale, sizeScale)
	part.Name = "TailPart_" .. i
	part.TopSurface, part.BottomSurface = Enum.SurfaceType.Smooth, Enum.SurfaceType.Smooth
	part.CFrame = prevPart.CFrame * CFrame.new(0, -0.5, -1)
	part.Parent = tailModel

	local att0 = Instance.new("Attachment", prevPart)
	local att1 = Instance.new("Attachment", part)

	local alignPos = Instance.new("AlignPosition", part)
	alignPos.Attachment0 = att1
	alignPos.Attachment1 = att0
	alignPos.RigidityEnabled = false
	alignPos.MaxForce = math.huge
	alignPos.Responsiveness = 15

	local alignOri = Instance.new("AlignOrientation", part)
	alignOri.Attachment0 = att1
	alignOri.Attachment1 = att0
	alignOri.RigidityEnabled = false
	alignOri.MaxTorque = math.huge
	alignOri.Responsiveness = 15

	part:SetNetworkOwner(player)
	table.insert(tailParts, part)
	prevPart = part
end

-- ADD SPINNING WHITE CUBE
task.wait(0.25) -- Let tail build
local tip = tailParts[#tailParts]
local whiteCube = Instance.new("Part")
whiteCube.Size = Vector3.new(2, 2, 2)
whiteCube.Shape = Enum.PartType.Block
whiteCube.Anchored = false
whiteCube.CanCollide = false
whiteCube.Material = Enum.Material.Neon
whiteCube.Color = Color3.new(1, 1, 1)
whiteCube.Name = "TailTipCube"
whiteCube.Parent = tailModel

local attTip = Instance.new("Attachment", tip)
local attCube = Instance.new("Attachment", whiteCube)

local alignPos = Instance.new("AlignPosition", whiteCube)
alignPos.Attachment0 = attCube
alignPos.Attachment1 = attTip
alignPos.Position = cubeOffset
alignPos.RigidityEnabled = false
alignPos.MaxForce = math.huge
alignPos.Responsiveness = 20

local alignOri = Instance.new("AlignOrientation", whiteCube)
alignOri.Attachment0 = attCube
alignOri.Attachment1 = attTip
alignOri.RigidityEnabled = false
alignOri.MaxTorque = math.huge
alignOri.Responsiveness = 20

-- SPINNING + COLOR SHIFTING CUBE
RunService.Heartbeat:Connect(function(dt)
	whiteCube.CFrame *= CFrame.Angles(0, math.rad(120 * dt), 0)
	local t = tick() * 0.3
	whiteCube.Color = Color3.fromHSV(t % 1, 0.7, 1)
end)

-- IDLE + BOREDOM
local lastMoveTime = tick()
local lastPos = root.Position
RunService.Heartbeat:Connect(function()
	local pos = root.Position
	if (pos - lastPos).magnitude > 0.1 then
		lastMoveTime = tick()
	end
	lastPos = pos

	if tick() - lastMoveTime > idleThreshold then
		local action = boredAnims[math.random(1, #boredAnims)]
		for _, p in ipairs(tailParts) do
			action(p)
		end
	end
end)
