local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local root = char:WaitForChild("HumanoidRootPart")

-- SETTINGS
local segmentCount = 4
local segmentLength = 1.5
local segments = {}

-- Helper to create tail segment
local function createSegment(index)
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.6, 0.6, segmentLength)
	part.Name = "TailSegment_" .. index
	part.Anchored = false
	part.CanCollide = false
	part.Material = Enum.Material.SmoothPlastic
	part.Color = Color3.fromRGB(100 + index * 30, 0, 255 - index * 40)
	part.CastShadow = false
	part.Parent = workspace

	local att0 = Instance.new("Attachment", part)

	local alignPos = Instance.new("AlignPosition", part)
	alignPos.Attachment0 = att0
	alignPos.Responsiveness = 80
	alignPos.RigidityEnabled = false
	alignPos.MaxForce = 20000

	local alignOri = Instance.new("AlignOrientation", part)
	alignOri.Attachment0 = att0
	alignOri.Responsiveness = 60
	alignOri.RigidityEnabled = false
	alignOri.MaxTorque = 20000

	return {
		Part = part,
		Attachment = att0,
		AlignPosition = alignPos,
		AlignOrientation = alignOri,
	}
end

-- Create all segments
for i = 1, segmentCount do
	local seg = createSegment(i)
	table.insert(segments, seg)
end

-- Update the tail every frame
RunService.RenderStepped:Connect(function(dt)
	local baseCF = root.CFrame * CFrame.new(0, -0.5, 1.5) -- behind lower back
	local velocity = root.Velocity

	for i, seg in ipairs(segments) do
		local offset = Vector3.new(0, 0, -segmentLength * (i - 1))
		offset = offset + Vector3.new(0, i * 0.1, 0) -- slight upward pitch
		local targetPos = baseCF.Position + (baseCF.LookVector * offset.Z) + Vector3.new(0, offset.Y, 0)

		local flick = Vector3.new(
			math.sin(tick() * 3 + i) * 0.2,
			math.cos(tick() * 2 + i) * 0.1,
			0
		)

		-- Add reactive movement based on torso velocity
		local reactive = -velocity.Unit * 0.3 * (i / segmentCount)
		if velocity.Magnitude < 1 then reactive = Vector3.zero end

		segments[i].Attachment.WorldPosition = targetPos + flick + reactive

		-- Look at previous segment (or root for first)
		local lookFrom = (i == 1) and root.Position or segments[i - 1].Part.Position
		local lookTo = segments[i].Part.Position
		local dir = (lookTo - lookFrom).Unit

		local up = Vector3.new(0, 1, 0)
		local cf = CFrame.lookAt(lookFrom, lookTo, up)
		segments[i].Attachment.WorldOrientation = cf.Rotation
	end
end)
