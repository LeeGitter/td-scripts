local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")
local rootPart = character:WaitForChild("HumanoidRootPart")

local segmentCount = 10
local radius = 2
local heightOffset = 3
local basePartSize = Vector3.new(0.3, 0.5, 0.3)
local soundDetectionRadius = 60
local maxLoudnessExpected = 1000
local maxPartHeight = 5

-- Clear existing crown folder if any
local crownFolder = workspace:FindFirstChild("VisualizerCrown")
if crownFolder then
    crownFolder:Destroy()
end
crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerCrown"
crownFolder.Parent = workspace

local parts = {}
local partScales = {}

for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = basePartSize
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Transparency = 0
    part.Name = "CrownPart"..i
    part.Parent = crownFolder
    parts[i] = part
    partScales[i] = basePartSize.Y
end

-- Variables for smooth tilt and wobble
local prevTiltX, prevTiltZ = 0, 0
local tiltSmoothing = 0.1
local tiltIntensity = 0.1

local wobbleDuration = 0.5
local wobbleTime = 0
local wobbleAmplitudePos = 0.2
local wobbleAmplitudeRot = 0.09
local wobbleActive = false

local lastPitch, lastRoll = 0, 0
local wobbleTriggerThreshold = 0.05

-- Highlight vars
local highlight = nil
local highlightTime = 0
local highlightDuration = 0.7  -- 0.2s fully visible + 0.5s fade out
local highlightFullyVisibleTime = 0.2
local rainbowCycleDuration = 0.5

-- Pillars trail vars
local trailFolder = workspace:FindFirstChild("PillarTrail")
if trailFolder then
    trailFolder:Destroy()
end
trailFolder = Instance.new("Folder")
trailFolder.Name = "PillarTrail"
trailFolder.Parent = workspace

local lastPillarSpawnTime = 0
local pillarSpawnInterval = 1 -- spawn every 1 second

local function createPillar(position, height, color)
    local pillar = Instance.new("Part")
    pillar.Anchored = true
    pillar.CanCollide = false
    pillar.Size = Vector3.new(0.2, height, 0.2)
    pillar.Position = position + Vector3.new(0, height / 2, 0)
    pillar.Material = Enum.Material.Neon
    pillar.Color = color
    pillar.Transparency = 0
    pillar.Parent = trailFolder

    -- Fade out over 10 seconds
    spawn(function()
        local lifeTime = 10
        local fadeTime = 4
        local startTime = tick()
        while tick() - startTime < lifeTime do
            local dt = RunService.Heartbeat:Wait()
            local elapsed = tick() - startTime
            if elapsed > lifeTime - fadeTime then
                pillar.Transparency = math.clamp((elapsed - (lifeTime - fadeTime)) / fadeTime, 0, 1)
            end
        end
        pillar:Destroy()
    end)
end

local function getSoundPosition(sound)
    if sound.Parent:IsA("BasePart") then
        return sound.Parent.Position
    elseif sound.Parent:IsA("Model") then
        if sound.Parent:FindFirstChild("HumanoidRootPart") then
            return sound.Parent.HumanoidRootPart.Position
        end
        for _, descendant in pairs(sound.Parent:GetDescendants()) do
            if descendant:IsA("BasePart") then
                return descendant.Position
            end
        end
    end
    return head.Position
end

local function getNearbySounds()
    local sounds = {}

    for _, sound in pairs(workspace:GetDescendants()) do
        if sound:IsA("Sound") and sound.IsPlaying then
            local pos = getSoundPosition(sound)
            if pos and (pos - head.Position).Magnitude <= soundDetectionRadius then
                table.insert(sounds, sound)
            end
        end
    end

    local function addLocalSounds(root)
        for _, sound in pairs(root:GetDescendants()) do
            if sound:IsA("Sound") and sound.IsPlaying then
                table.insert(sounds, sound)
            end
        end
    end

    addLocalSounds(player:WaitForChild("PlayerGui"))
    addLocalSounds(character)

    return sounds
end

RunService.Heartbeat:Connect(function(dt)
    local headCFrame = head.CFrame
    local pitch, roll = headCFrame:ToEulerAnglesXYZ()

    if math.abs(pitch - lastPitch) > wobbleTriggerThreshold or math.abs(roll - lastRoll) > wobbleTriggerThreshold then
        wobbleActive = true
        wobbleTime = 0
    end
    lastPitch = pitch
    lastRoll = roll

    local targetTiltX = -pitch * tiltIntensity
    local targetTiltZ = -roll * tiltIntensity
    prevTiltX = prevTiltX + (targetTiltX - prevTiltX) * tiltSmoothing
    prevTiltZ = prevTiltZ + (targetTiltZ - prevTiltZ) * tiltSmoothing

    if wobbleActive then
        wobbleTime = wobbleTime + dt
        if wobbleTime > wobbleDuration then
            wobbleActive = false
            wobbleTime = wobbleDuration
        end
    end

    local wobbleProgress = wobbleTime / wobbleDuration
    local wobblePosOffset = 0
    local wobbleRotOffset = 0
    if wobbleActive then
        local decay = 1 - wobbleProgress
        wobblePosOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudePos * decay
        wobbleRotOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudeRot * decay
    end

    local tiltRotation = CFrame.Angles(prevTiltX, 0, prevTiltZ + wobbleRotOffset)
    local baseCFrame = headCFrame * CFrame.new(wobblePosOffset, heightOffset, 0) * tiltRotation

    local sounds = getNearbySounds()

    local highlightTriggeredThisFrame = false

    for i, part in ipairs(parts) do
        local angle = (2 * math.pi / segmentCount) * i
        local localOffset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
        local worldPos = baseCFrame:PointToWorldSpace(localOffset)

        local soundIndex = #sounds > 0 and ((i - 1) % #sounds) + 1 or nil
        local sound = soundIndex and sounds[soundIndex] or nil

        local loudness = 0
        if sound then
            loudness = sound.PlaybackLoudness or 0
        end

        local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
        local targetHeight = 0.5 + normalized * (maxPartHeight - 0.5)

        partScales[i] = partScales[i] + (targetHeight - partScales[i]) * 0.15
        part.Size = Vector3.new(basePartSize.X, partScales[i], basePartSize.Z)

        part.Position = worldPos + Vector3.new(0, partScales[i] / 2, 0)

        local yawAngle = math.deg(math.atan2(localOffset.Z, localOffset.X))
        part.Orientation = Vector3.new(0, yawAngle, 0)

        if not highlightTriggeredThisFrame and partScales[i] >= maxPartHeight - 0.1 then
            highlightTriggeredThisFrame = true
        end
    end

    -- Pillars spawn only if moving (speed > 1)
    local speed = rootPart.Velocity.Magnitude
    if speed > 1 and tick() - lastPillarSpawnTime > pillarSpawnInterval then
        for i, part in ipairs(parts) do
            local pos = part.Position
            local loudness = 0
            -- Find corresponding sound for this part (same logic as above)
            local soundIndex = #sounds > 0 and ((i - 1) % #sounds) + 1 or nil
            local sound = soundIndex and sounds[soundIndex] or nil
            if sound then
                loudness = sound.PlaybackLoudness or 0
            end

            local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
            local height = 0.5 + normalized * (maxPartHeight - 0.5)

            local color = Color3.fromHSV((i / segmentCount + tick()) % 1, 0.7, 1) -- pastel rainbow

            createPillar(pos, height, color)
        end
        lastPillarSpawnTime = tick()
    end

    if highlightTriggeredThisFrame then
        highlightTime = 0
        createHighlight()
    end

    if highlight then
        highlightTime = highlightTime + dt
        local hue = (highlightTime % rainbowCycleDuration) / rainbowCycleDuration
        highlight.FillColor = Color3.fromHSV(hue, 1, 1)

        if highlightTime < highlightFullyVisibleTime then
            highlight.FillTransparency = 0
        elseif highlightTime < highlightDuration then
            local fadeProgress = (highlightTime - highlightFullyVisibleTime) / (highlightDuration - highlightFullyVisibleTime)
            highlight.FillTransparency = fadeProgress
        else
            removeHighlight()
        end
    end
end)
