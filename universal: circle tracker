local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local head = char:WaitForChild("Head")
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")

-- SETTINGS
local numCrownParts = 12
local crownRadius = 3
local tailLength = 14
local tailSpacing = 0.6
local hopCooldown = 0.5
local rainbowColors = {}
for i = 0, 360, 30 do
	table.insert(rainbowColors, Color3.fromHSV(i / 360, 1, 1))
end

-- CLEANUP
for _, obj in ipairs(char:GetChildren()) do
	if obj.Name == "RainbowCrown" or obj.Name == "RainbowTail" then
		obj:Destroy()
	end
end

-- STORAGE
local crownFolder = Instance.new("Folder", char)
crownFolder.Name = "RainbowCrown"
local crownParts = {}

local tailFolder = Instance.new("Folder", char)
tailFolder.Name = "RainbowTail"
local tailParts = {}

-- CREATE CROWN (Block Parts)
for i = 1, numCrownParts do
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.4, 0.4, 0.4)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = rainbowColors[(i % #rainbowColors) + 1]
	part.Parent = crownFolder
	table.insert(crownParts, part)
end

-- CREATE TAIL
for i = 1, tailLength do
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.5, 0.5, 0.5)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = rainbowColors[((i * 3) % #rainbowColors) + 1]
	part.Parent = tailFolder
	table.insert(tailParts, part)
end

-- CREATE AFTERIMAGE (with Meshes)
local function createAfterimage()
	local clone = Instance.new("Model")
	clone.Name = "Afterimage"

	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			local newPart = part:Clone()
			newPart.Anchored = true
			newPart.CanCollide = false
			newPart.Transparency = 0.6
			newPart.Material = Enum.Material.Neon
			newPart.Color = rainbowColors[math.random(1, #rainbowColors)]
			newPart.Velocity = Vector3.zero

			for _, child in ipairs(newPart:GetChildren()) do
				if child:IsA("Decal") or child:IsA("Texture") then
					child:Destroy()
				end
			end

			newPart.Parent = clone
		end
	end

	clone.Parent = workspace
	Debris:AddItem(clone, 0.3)
end

-- Hop logic
local isHopping = false
local lastHop = 0
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://125869734469543"

UserInputService.InputBegan:Connect(function(input, gp)
	if gp or input.KeyCode ~= Enum.KeyCode.Space then return end
	if tick() - lastHop < hopCooldown then return end
	if not char or not char.Parent then return end
	lastHop = tick()

	local animTrack = humanoid:LoadAnimation(anim)
	animTrack:Play(0, 1, 1.5)
	animTrack.Priority = Enum.AnimationPriority.Action

	local duration = 0.1
	local start = tick()
	local dir = hrp.CFrame.LookVector
	local hopStart = hrp.Position
	local upwardVelocity = Vector3.new(0, 2, 0)
	local forwardVelocity = dir * 5

	isHopping = true
	local afterimagesSpawned = 0

	RunService.RenderStepped:Connect(function()
		if not isHopping then return end
		local now = tick()
		local delta = now - start
		if delta >= duration then
			isHopping = false
			return
		end

		local t = delta / duration
		hrp.Velocity = upwardVelocity + forwardVelocity

		if afterimagesSpawned < 5 and t >= (afterimagesSpawned * 0.02) then
			createAfterimage()
			afterimagesSpawned += 1
		end
	end)

	task.delay(0.15, function()
		animTrack:Stop()
	end)
end)

-- AUDIO DETECTION
local loudness = 0
local isBuff = false
local lastSoundScan = tick()

-- MAIN LOOP
RunService.RenderStepped:Connect(function(dt)
	local now = tick()

	-- === AUDIO INTENSITY CHECK ===
	if now - lastSoundScan > 0.1 then
		lastSoundScan = now
		local volume = 0

		for _, sound in ipairs(head:GetDescendants()) do
			if sound:IsA("Sound") and sound.IsPlaying then
				volume += sound.PlaybackLoudness or 0
			end
		end

		for _, sound in ipairs(SoundService:GetDescendants()) do
			if sound:IsA("Sound") and sound.IsPlaying then
				volume += (sound.PlaybackLoudness or 0) * 0.3
			end
		end

		loudness = volume
		isBuff = loudness > 60
	end

	-- === CROWN UPDATE ===
	for i, part in ipairs(crownParts) do
		local angle = math.rad((360 / #crownParts) * i + tick() * 60)
		local wobble = math.sin(tick() * 3 + i) * 0.3
		local offset = Vector3.new(math.cos(angle) * (crownRadius + wobble), 2 + wobble, math.sin(angle) * (crownRadius + wobble))
		part.Position = head.Position + offset
		part.Color = rainbowColors[(i + math.floor(tick() * 10)) % #rainbowColors + 1]
	end

	-- === TAIL UPDATE ===
	local rootCF = hrp.CFrame
	for i, part in ipairs(tailParts) do
		local offset = Vector3.new(0, -0.4, -i * tailSpacing)
		local worldPos = rootCF:PointToWorldSpace(offset)
		part.Position = part.Position:Lerp(worldPos, dt * 10)
		part.Color = rainbowColors[((i + math.floor(tick() * 15)) % #rainbowColors) + 1]
	end
end)
