local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local head = character:WaitForChild("Head")
local humanoid = character:WaitForChild("Humanoid")

-------------------------------
-- Tail Configuration
-------------------------------
local NUM_SEGMENTS = 16
local BASE_SIZE = Vector3.new(0.5, 0.5, 0.7)
local LENGTH_PER_SEGMENT = 0.7
local BASE_OFFSET = Vector3.new(0, -1.5, 1.5)
local MAX_PITCH_ANGLE = math.rad(30)
local BUILD_DELAY = 0.05

if character:FindFirstChild("DynamicTailModel") then
	character.DynamicTailModel:Destroy()
end

local tailModel = Instance.new("Model")
tailModel.Name = "DynamicTailModel"
tailModel.Parent = character

local tailRootAttachment = Instance.new("Attachment")
tailRootAttachment.Name = "TailRootAttachment"
tailRootAttachment.Position = BASE_OFFSET
tailRootAttachment.Parent = torso

local segments, attachments = {}, {}

local function createSegment(index)
	local part = Instance.new("Part")
	part.Name = "TailSegment_" .. index
	local sizeMultiplier = 1 + (index / NUM_SEGMENTS) * 1.5
	part.Size = Vector3.new(BASE_SIZE.X * sizeMultiplier, BASE_SIZE.Y * sizeMultiplier, LENGTH_PER_SEGMENT)
	part.Material = Enum.Material.Neon
	part.Anchored = false
	part.CanCollide = false
	part.Massless = true
	part.CastShadow = false
	part.Color = Color3.fromHSV((index / NUM_SEGMENTS) % 1, 1, 1)
	part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	part.Parent = tailModel

	local att0 = Instance.new("Attachment", part)
	att0.Name = "Attachment0"
	att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local att1 = Instance.new("Attachment", part)
	att1.Name = "Attachment1"
	att1.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	return part, att0, att1
end

for i = 1, NUM_SEGMENTS do
	local part, att0, att1 = createSegment(i)
	segments[i] = part
	attachments[i] = {att0, att1}
	local t = (i - 1) / (NUM_SEGMENTS - 1)
	local pitchAngle = MAX_PITCH_ANGLE * t
	local basePos = Vector3.new(0, BASE_OFFSET.Y, -BASE_OFFSET.Z - LENGTH_PER_SEGMENT * (i - 1))
	local cframe = torso.CFrame * CFrame.new(basePos) * CFrame.Angles(pitchAngle, 0, 0)
	part.CFrame = cframe
	part.Anchored = true
	wait(BUILD_DELAY)
end

for i = 1, NUM_SEGMENTS do
	local part = segments[i]
	part.Anchored = false
	local att0, att1 = attachments[i][1], attachments[i][2]
	local attachA = (i == 1) and tailRootAttachment or attachments[i - 1][2]
	local attachB = att0

	local alignPos = Instance.new("AlignPosition")
	alignPos.Attachment0 = attachB
	alignPos.Attachment1 = attachA
	alignPos.MaxForce = 10000
	alignPos.Responsiveness = 50
	alignPos.RigidityEnabled = false
	alignPos.Parent = part

	local alignOri = Instance.new("AlignOrientation")
	alignOri.Attachment0 = attachB
	alignOri.Attachment1 = attachA
	alignOri.MaxTorque = 10000
	alignOri.Responsiveness = 50
	alignOri.Parent = part
end

local wobbleSpeed = 2
local wobbleMagnitude = 0.05

RunService.RenderStepped:Connect(function()
	local velocity = torso.Velocity.Magnitude
	local time = tick()
	for i, part in ipairs(segments) do
		local phase = time * wobbleSpeed + i
		local swayX = math.sin(phase) * wobbleMagnitude * (velocity / 20)
		local swayY = math.cos(phase * 1.5) * wobbleMagnitude * (velocity / 20)
		local att0, att1 = attachments[i][1], attachments[i][2]
		att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2) + Vector3.new(swayX, swayY, 0)
	end
end)

-------------------------------
-- Crown Configuration
-------------------------------
local segmentCount = 10
local radius = 2
local heightOffset = 3
local basePartSize = Vector3.new(0.3, 0.5, 0.3)
local soundDetectionRadius = 60
local maxLoudnessExpected = 1000
local maxPartHeight = 5

local crownFolder = workspace:FindFirstChild("VisualizerCrown")
if crownFolder then
	crownFolder:Destroy()
end
crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerCrown"
crownFolder.Parent = workspace

local parts = {}
local partScales = {}

for i = 1, segmentCount do
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = basePartSize
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
	part.Transparency = 0
	part.Name = "CrownPart" .. i
	part.Parent = crownFolder
	parts[i] = part
	partScales[i] = basePartSize.Y
end

local prevTiltX, prevTiltZ = 0, 0
local tiltSmoothing = 0.1
local tiltIntensity = 0.1
local wobbleDuration = 0.5
local wobbleTime = 0
local wobbleAmplitudePos = 0.2
local wobbleAmplitudeRot = 0.09
local wobbleActive = false
local lastPitch, lastRoll = 0, 0
local wobbleTriggerThreshold = 0.05

local cachedSounds = {}
local timeSinceLastScan = 0
local scanInterval = 0.1

local function getSoundPosition(sound)
	if sound.Parent:IsA("BasePart") then
		return sound.Parent.Position
	elseif sound.Parent:IsA("Model") then
		local hrp = sound.Parent:FindFirstChild("HumanoidRootPart")
		if hrp then return hrp.Position end
		for _, d in pairs(sound.Parent:GetDescendants()) do
			if d:IsA("BasePart") then return d.Position end
		end
	end
	return head.Position
end

local function getNearbySounds(dt)
	timeSinceLastScan += dt
	if timeSinceLastScan < scanInterval then
		return cachedSounds
	end
	timeSinceLastScan = 0

	local sounds = {}

	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.IsPlaying then
			local pos = getSoundPosition(sound)
			if (pos - head.Position).Magnitude <= soundDetectionRadius then
				local isFloating = not sound.Parent:IsA("BasePart") and not sound.Parent:IsA("Model")
				table.insert(sounds, {
					Instance = sound,
					IsFloating = isFloating
				})
			end
		end
	end

	local function addLocalSounds(root)
		for _, sound in pairs(root:GetDescendants()) do
			if sound:IsA("Sound") and sound.IsPlaying then
				table.insert(sounds, {
					Instance = sound,
					IsFloating = false
				})
			end
		end
	end

	addLocalSounds(player:WaitForChild("PlayerGui"))
	addLocalSounds(character)

	cachedSounds = sounds
	return sounds
end

RunService.Heartbeat:Connect(function(dt)
	local headCFrame = head.CFrame
	local pitch, roll = headCFrame:ToEulerAnglesXYZ()

	if math.abs(pitch - lastPitch) > wobbleTriggerThreshold or math.abs(roll - lastRoll) > wobbleTriggerThreshold then
		wobbleActive = true
		wobbleTime = 0
	end
	lastPitch, lastRoll = pitch, roll

	local targetTiltX = -pitch * tiltIntensity
	local targetTiltZ = -roll * tiltIntensity
	prevTiltX += (targetTiltX - prevTiltX) * tiltSmoothing
	prevTiltZ += (targetTiltZ - prevTiltZ) * tiltSmoothing

	if wobbleActive then
		wobbleTime += dt
		if wobbleTime > wobbleDuration then
			wobbleActive = false
			wobbleTime = wobbleDuration
		end
	end

	local wobbleProgress = wobbleTime / wobbleDuration
	local wobblePosOffset = 0
	local wobbleRotOffset = 0
	if wobbleActive then
		local decay = 1 - wobbleProgress
		wobblePosOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudePos * decay
		wobbleRotOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudeRot * decay
	end

	local tiltRotation = CFrame.Angles(prevTiltX, 0, prevTiltZ + wobbleRotOffset)
	local baseCFrame = headCFrame * CFrame.new(wobblePosOffset, heightOffset, 0) * tiltRotation

	local sounds = getNearbySounds(dt)

	for i, part in ipairs(parts) do
		local angle = (2 * math.pi / segmentCount) * i
		local localOffset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
		local worldPos = baseCFrame:PointToWorldSpace(localOffset)

		local soundData = #sounds > 0 and sounds[((i - 1) % #sounds) + 1] or nil
		local sound = soundData and soundData.Instance or nil

		local loudness = 0
		if sound then
			loudness = sound.PlaybackLoudness or 0
			if soundData.IsFloating then
				loudness *= 2.5
			end
		end

		local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
		local targetHeight = 0.5 + normalized * (maxPartHeight - 0.5)

		partScales[i] += (targetHeight - partScales[i]) * 0.25
		part.Size = Vector3.new(basePartSize.X, partScales[i], basePartSize.Z)
		part.Position = worldPos + Vector3.new(0, partScales[i] / 2, 0)

		local yawAngle = math.deg(math.atan2(localOffset.Z, localOffset.X))
		part.Orientation = Vector3.new(0, yawAngle, 0)
	end
end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Animation Setup
local dashAnim = Instance.new("Animation")
dashAnim.AnimationId = "rbxassetid://125869734469543"
local dashTrack = humanoid:LoadAnimation(dashAnim)
dashTrack.Priority = Enum.AnimationPriority.Action

-- GUI Setup
local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
screenGui.Name = "DashBarGui"

local outerBar = Instance.new("Frame", screenGui)
outerBar.AnchorPoint = Vector2.new(0.5, 1)
outerBar.Position = UDim2.new(0.5, 0, 1, -40)
outerBar.Size = UDim2.new(0.5, 0, 0, 24)
outerBar.BackgroundColor3 = Color3.new(0, 0, 0)
outerBar.BorderSizePixel = 0
outerBar.BackgroundTransparency = 0.3
outerBar.ClipsDescendants = true
outerBar.Name = "OuterBar"
outerBar.ZIndex = 5
outerBar:FindFirstChildOfClass("UICorner") or Instance.new("UICorner", outerBar).CornerRadius = UDim.new(1, 0)

-- Add 5 vertical guide lines
for i = 1, 4 do
	local line = Instance.new("Frame", outerBar)
	line.Size = UDim2.new(0, 2, 1, 0)
	line.Position = UDim2.new(i / 5, -1, 0, 0)
	line.BackgroundColor3 = Color3.new(1, 1, 1)
	line.BackgroundTransparency = 0.5
	line.BorderSizePixel = 0
	line.ZIndex = 6
end

-- Fill bar
local fill = Instance.new("Frame", outerBar)
fill.Size = UDim2.new(0, 0, 1, 0)
fill.Position = UDim2.new(0, 0, 0, 0)
fill.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
fill.BorderSizePixel = 0
fill.ZIndex = 4

-- Text label
local textLabel = Instance.new("TextLabel", outerBar)
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.Font = Enum.Font.GothamBold
textLabel.TextSize = 16
textLabel.Text = ""
textLabel.ZIndex = 7

-- Control variables
local charging = false
local chargeTime = 1
local dashTime = 3
local dashSpeed = 30
local chargeStartTime = 0
local isDashing = false
local afterimageCooldown = 0

-- Afterimage function
local pastelColors = {
	Color3.fromRGB(255, 180, 180),
	Color3.fromRGB(180, 255, 180),
	Color3.fromRGB(180, 180, 255),
	Color3.fromRGB(255, 255, 180),
	Color3.fromRGB(255, 180, 255),
	Color3.fromRGB(180, 255, 255)
}
local colorIndex = 1

local function createAfterimage()
	local clone = character:Clone()
	clone.Name = "AfterImage"
	for _, desc in ipairs(clone:GetDescendants()) do
		if desc:IsA("BasePart") then
			if desc.Transparency >= 1 or desc.Name == "CollisionHitbox" then
				desc:Destroy()
			else
				desc.Anchored = true
				desc.CanCollide = false
				desc.Material = Enum.Material.Neon
				desc.Color = pastelColors[colorIndex]
				colorIndex = (colorIndex % #pastelColors) + 1
				desc.Size *= 0.95
			end
		elseif desc:IsA("Decal") or desc:IsA("Script") or desc:IsA("LocalScript") then
			desc:Destroy()
		end
	end
	clone:SetPrimaryPartCFrame(hrp.CFrame)
	clone.Parent = workspace
	Debris:AddItem(clone, 0.3)
	for _, part in ipairs(clone:GetDescendants()) do
		if part:IsA("BasePart") then
			TweenService:Create(part, TweenInfo.new(0.3), {Transparency = 1}):Play()
		end
	end
end

-- Dash function
local function beginDash()
	if isDashing then return end
	isDashing = true
	local startTime = tick()
	dashTrack:Play()
	RunService:BindToRenderStep("DashMovement", Enum.RenderPriority.Character.Value + 1, function(dt)
		local now = tick()
		if now - startTime >= dashTime then
			RunService:UnbindFromRenderStep("DashMovement")
			isDashing = false
			dashTrack:Stop()
			return
		end

		local cam = workspace.CurrentCamera
		local forward = cam.CFrame.LookVector * Vector3.new(1, 0, 1)
		local input = Vector3.new(0, 0, 0)
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then input = input + Vector3.new(0, 0, -1) end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then input = input + Vector3.new(0, 0, 1) end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then input = input + Vector3.new(-1, 0, 0) end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then input = input + Vector3.new(1, 0, 0) end
		input = input.Unit.Magnitude > 0 and input.Unit or Vector3.zero
		local moveDirection = (cam.CFrame:VectorToWorldSpace(input)).Unit
		local finalDirection = (forward + moveDirection * 0.4).Unit
		hrp.Velocity = finalDirection * dashSpeed

		if tick() - afterimageCooldown >= 0.05 then
			createAfterimage()
			afterimageCooldown = tick()
		end
	end)
end

-- Input handling
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.Space or charging or isDashing then return end
	charging = true
	chargeStartTime = tick()
end)

UserInputService.InputEnded:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.Space or not charging then return end
	charging = false
	if tick() - chargeStartTime >= chargeTime then
		fill.Size = UDim2.new(0, 0, 1, 0)
		textLabel.Text = ""
		beginDash()
	else
		fill:TweenSize(UDim2.new(0, 0, 1, 0), "Out", "Quad", 0.2, true)
		textLabel.Text = ""
	end
end)

-- Charge UI fill updater
RunService.RenderStepped:Connect(function()
	if charging and not isDashing then
		local progress = math.clamp((tick() - chargeStartTime) / chargeTime, 0, 1)
		fill.Size = UDim2.new(progress, 0, 1, 0)
		if progress >= 1 then
			textLabel.Text = "RELEASE!!!"
		end
	end
end)
