-- LocalScript inside StarterPlayerScripts
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- CONFIGURABLES
local tailLength = 16
local segmentDistance = 1.2
local wobbleAmplitude = 0.2
local wobbleSpeed = 8
local boredDelay = 4

-- STORAGE
local tailParts = {}
local bored = false
local lastMove = tick()
local rootVelocity = Vector3.zero

-- HELPER: Create tail segment
local function createSegment(index)
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.6, 0.6, 0.6)
	part.Shape = Enum.PartType.Ball
	part.Material = Enum.Material.SmoothPlastic
	part.Color = Color3.fromRGB(255 - index*5, 100 + index*10, 255)
	part.Anchored = true
	part.CanCollide = false
	part.CastShadow = false
	part.Name = "TailSegment_" .. index
	part.Parent = workspace
	return part
end

-- CREATE TAIL
for i = 1, tailLength do
	tailParts[i] = createSegment(i)
end

-- CUBE TIP
local tipCube
local cubeOffset = CFrame.new(0, 0, -10)

-- MAKE ROTATING GLOWY CUBE
local function makeTipCube()
	tipCube = Instance.new("Part")
	tipCube.Name = "TailCube"
	tipCube.Size = Vector3.new(1.25, 1.25, 1.25)
	tipCube.Shape = Enum.PartType.Block
	tipCube.Color = Color3.new(1, 1, 1)
	tipCube.Material = Enum.Material.Neon
	tipCube.Anchored = true
	tipCube.CanCollide = false
	tipCube.CastShadow = false
	tipCube.Parent = workspace

	local light = Instance.new("PointLight", tipCube)
	light.Color = Color3.new(1, 1, 1)
	light.Range = 8
	light.Brightness = 2

	return tipCube
end

-- COLOR SHIFT FUNCTION
local function colorShift(t)
	local h = (tick() * 0.1 + t) % 1
	return Color3.fromHSV(h, 1, 1)
end

-- BORED ANIMATIONS
local boredState = 0
local function applyBoredAnimation()
	if not bored then return end
	local t = tick()

	for i, part in ipairs(tailParts) do
		local offset = Vector3.new(
			math.sin(t * 1.5 + i) * 1.2,
			math.cos(t * 1.5 + i) * 0.8,
			math.sin(t * 0.5 + i) * 1.2
		)
		local targetPos = root.Position - root.CFrame.LookVector * (i * segmentDistance) + offset
		part.CFrame = CFrame.new(targetPos)
	end

	if tipCube then
		local tip = tailParts[#tailParts]
		tipCube.CFrame = tip.CFrame:ToWorldSpace(cubeOffset) * CFrame.Angles(0, tick() * 2, 0)
		tipCube.Color = colorShift(tick())
	end
end

-- MAIN LOOP
RunService.RenderStepped:Connect(function(dt)
	local moving = root.Velocity.Magnitude > 1

	if moving then
		lastMove = tick()
		bored = false
	else
		if tick() - lastMove > boredDelay then
			bored = true
		end
	end

	if bored then
		applyBoredAnimation()
		return
	end

	local t = tick()
	local basePos = root.Position - Vector3.new(0, 1.5, 0)
	local lastPos = basePos

	for i, part in ipairs(tailParts) do
		local offset = Vector3.new(
			math.sin(t * wobbleSpeed + i) * wobbleAmplitude,
			math.cos(t * wobbleSpeed + i) * wobbleAmplitude,
			0
		)

		local targetPos = lastPos - root.CFrame.LookVector * segmentDistance + offset
		part.CFrame = CFrame.new(targetPos)
		lastPos = targetPos
	end

	if not tipCube then
		tipCube = makeTipCube()
	end

	local finalSegment = tailParts[#tailParts]
	tipCube.CFrame = finalSegment.CFrame:ToWorldSpace(cubeOffset) * CFrame.Angles(0, tick() * 3, 0)
	tipCube.Color = colorShift(tick())
end)
