local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local head = character:WaitForChild("Head")

-------------------------------
-- Tail Configuration
-------------------------------
local NUM_SEGMENTS = 16
local BASE_SIZE = Vector3.new(0.5, 0.5, 0.7)
local LENGTH_PER_SEGMENT = 0.7
local BASE_OFFSET = Vector3.new(0, -1.5, 1.5)
local MAX_PITCH_ANGLE = math.rad(30)
local BUILD_DELAY = 0.05

if character:FindFirstChild("DynamicTailModel") then
	character.DynamicTailModel:Destroy()
end

local tailModel = Instance.new("Model")
tailModel.Name = "DynamicTailModel"
tailModel.Parent = character

local tailRootAttachment = Instance.new("Attachment")
tailRootAttachment.Name = "TailRootAttachment"
tailRootAttachment.Position = BASE_OFFSET
tailRootAttachment.Parent = torso

local segments, attachments = {}, {}

local function createSegment(index)
	local part = Instance.new("Part")
	part.Name = "TailSegment_" .. index
	local sizeMultiplier = 1 + (index / NUM_SEGMENTS) * 1.5
	part.Size = Vector3.new(BASE_SIZE.X * sizeMultiplier, BASE_SIZE.Y * sizeMultiplier, LENGTH_PER_SEGMENT)
	part.Material = Enum.Material.Neon
	part.Anchored = false
	part.CanCollide = false
	part.Massless = true
	part.CastShadow = false
	part.Color = Color3.fromHSV((index / NUM_SEGMENTS) % 1, 1, 1)
	part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	part.Parent = tailModel

	local att0 = Instance.new("Attachment", part)
	att0.Name = "Attachment0"
	att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local att1 = Instance.new("Attachment", part)
	att1.Name = "Attachment1"
	att1.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	return part, att0, att1
end

for i = 1, NUM_SEGMENTS do
	local part, att0, att1 = createSegment(i)
	segments[i] = part
	attachments[i] = {att0, att1}
	local t = (i - 1) / (NUM_SEGMENTS - 1)
	local pitchAngle = MAX_PITCH_ANGLE * t
	local basePos = Vector3.new(0, BASE_OFFSET.Y, -BASE_OFFSET.Z - LENGTH_PER_SEGMENT * (i - 1))
	local cframe = torso.CFrame * CFrame.new(basePos) * CFrame.Angles(pitchAngle, 0, 0)
	part.CFrame = cframe
	part.Anchored = true
	wait(BUILD_DELAY)
end

for i = 1, NUM_SEGMENTS do
	local part = segments[i]
	part.Anchored = false
	local att0, att1 = attachments[i][1], attachments[i][2]
	local attachA = (i == 1) and tailRootAttachment or attachments[i - 1][2]
	local attachB = att0

	local alignPos = Instance.new("AlignPosition")
	alignPos.Attachment0 = attachB
	alignPos.Attachment1 = attachA
	alignPos.MaxForce = 10000
	alignPos.Responsiveness = 50
	alignPos.RigidityEnabled = false
	alignPos.Parent = part

	local alignOri = Instance.new("AlignOrientation")
	alignOri.Attachment0 = attachB
	alignOri.Attachment1 = attachA
	alignOri.MaxTorque = 10000
	alignOri.Responsiveness = 50
	alignOri.Parent = part
end

local wobbleSpeed = 2
local wobbleMagnitude = 0.05

RunService.RenderStepped:Connect(function()
	local velocity = torso.Velocity.Magnitude
	local time = tick()
	for i, part in ipairs(segments) do
		local phase = time * wobbleSpeed + i
		local swayX = math.sin(phase) * wobbleMagnitude * (velocity / 20)
		local swayY = math.cos(phase * 1.5) * wobbleMagnitude * (velocity / 20)
		local att0 = attachments[i][1]
		att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2) + Vector3.new(swayX, swayY, 0)
	end
end)

-------------------------------
-- Crown Configuration
-------------------------------
local soundDetectionRadius = 100
local totalParts = 6
local localPartCount = 3
local globalPartCount = totalParts - localPartCount
local radius = 12

local partHeight = 2
local baseSize = Vector3.new(1, partHeight, 1)
local parts = {}

local function createPart(color)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = baseSize
	part.Shape = Enum.PartType.Cylinder
	part.Material = Enum.Material.Neon
	part.Color = color
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	part.Parent = workspace
	return part
end

for i = 1, totalParts do
	local color = i <= localPartCount and Color3.fromRGB(50, 200, 255) or Color3.fromRGB(255, 50, 100)
	table.insert(parts, createPart(color))
end

local function getSoundPosition(sound)
	if sound:IsDescendantOf(workspace) and sound.Parent:IsA("BasePart") then
		return sound.Parent.Position
	elseif sound:IsDescendantOf(workspace) and sound.Parent:IsA("Model") then
		local model = sound.Parent
		if model.PrimaryPart then
			return model.PrimaryPart.Position
		else
			local total = Vector3.zero
			local count = 0
			for _, p in ipairs(model:GetDescendants()) do
				if p:IsA("BasePart") then
					total += p.Position
					count += 1
				end
			end
			return count > 0 and total / count or Vector3.zero
		end
	end
	return Vector3.zero
end

local function getNearbySounds()
	local sounds = {}

	for _, sound in ipairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.IsPlaying then
			local pos = getSoundPosition(sound)
			local dist = (pos - head.Position).Magnitude
			if dist <= soundDetectionRadius then
				local isFloating = not sound.Parent:IsA("BasePart") and not sound.Parent:IsA("Model")
				table.insert(sounds, {
					Instance = sound,
					Distance = dist,
					IsFloating = isFloating,
					IsLocal = false
				})
			end
		end
	end

	local function addLocal(root)
		for _, sound in ipairs(root:GetDescendants()) do
			if sound:IsA("Sound") and sound.IsPlaying then
				table.insert(sounds, {
					Instance = sound,
					Distance = 0,
					IsFloating = false,
					IsLocal = true
				})
			end
		end
	end

	addLocal(character)
	addLocal(player:WaitForChild("PlayerGui"))
	return sounds
end

local function assignSoundsToParts(sounds)
	local assigned = table.create(totalParts)
	for _, s in ipairs(sounds) do
		local targetIndex
		if s.IsLocal then
			targetIndex = math.random(1, localPartCount)
		else
			targetIndex = math.random(localPartCount + 1, totalParts)
		end
		assigned[targetIndex] = assigned[targetIndex] or s
	end
	return assigned
end

local function getAdjustedLoudness(raw, isFloating)
	raw = raw or 0
	local sensitivityBoost = isFloating and 3 or 2
	local normalized = math.clamp(raw / 150, 0, 1)
	return (normalized ^ 0.5) * sensitivityBoost
end

RunService.Heartbeat:Connect(function()
	local sounds = getNearbySounds()
	local soundMap = assignSoundsToParts(sounds)
	local cameraCF = workspace.CurrentCamera.CFrame
	local right = cameraCF.RightVector
	local forward = cameraCF.LookVector

	for i, part in ipairs(parts) do
		local angle = (math.pi * 2 / totalParts) * (i - 1)
		local offset = (right * math.cos(angle) + forward * math.sin(angle)) * radius
		local position = head.Position + Vector3.new(0, 4, 0) + offset

		local soundData = soundMap[i]
		local loudness = 0

		if soundData and soundData.Instance then
			local s = soundData.Instance
			loudness = getAdjustedLoudness(s.PlaybackLoudness, soundData.IsFloating)
		end

		local scale = math.clamp(loudness * 2, 0.2, 6)
		part.Size = Vector3.new(scale, partHeight, scale)
		part.CFrame = CFrame.new(position, position + Vector3.new(0, 1, 0)) * CFrame.Angles(0, 0, math.rad(90))
	end
end)
