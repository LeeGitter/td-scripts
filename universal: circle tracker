local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Wing asset info
local wingImageId = "rbxassetid://75171109405668"
local flapSpeedMultiplier = 1.5
local afterimageDuration = 0.5
local afterimageInterval = 0.1
local wingOffset = Vector3.new(0.5, 1, -1)

-- Create the wings
local function createWing(isLeft)
	local wing = Instance.new("BillboardGui")
	wing.Name = isLeft and "LeftWing" or "RightWing"
	wing.Size = UDim2.new(2, 0, 2, 0)
	wing.StudsOffset = wingOffset * Vector3.new(isLeft and -1 or 1, 1, 1)
	wing.AlwaysOnTop = true
	wing.Adornee = humanoidRootPart
	wing.Parent = character

	local image = Instance.new("ImageLabel")
	image.BackgroundTransparency = 1
	image.Size = UDim2.new(1, 0, 1, 0)
	image.Image = wingImageId
	image.ImageColor3 = Color3.new(1, 1, 1)
	image.ImageTransparency = 0
	image.Parent = wing

	return wing
end

local leftWing = createWing(true)
local rightWing = createWing(false)

-- Rainbow afterimage system
local function createAfterimage(w)
	local clone = w:Clone()
	clone.Parent = w.Parent
	local image = clone:FindFirstChildWhichIsA("ImageLabel")
	if image then
		local hue = tick() % 5 / 5
		image.ImageColor3 = Color3.fromHSV(hue, 1, 1)
		image.ImageTransparency = 0.3
	end

	task.delay(afterimageDuration, function()
		clone:Destroy()
	end)
end

-- Wing flapping based on movement
local lastPos = humanoidRootPart.Position
local timeSinceAfterimage = 0
RunService.RenderStepped:Connect(function(dt)
	local currentPos = humanoidRootPart.Position
	local speed = (currentPos - lastPos).Magnitude / dt
	lastPos = currentPos

	local flapAngle = math.sin(tick() * flapSpeedMultiplier + speed * 0.1) * 15

	for _, wing in pairs({leftWing, rightWing}) do
		local gui = wing:FindFirstChildWhichIsA("ImageLabel")
		if gui then
			gui.Rotation = (wing.Name == "LeftWing" and -1 or 1) * flapAngle
		end
	end

	timeSinceAfterimage += dt
	if timeSinceAfterimage >= afterimageInterval and speed > 2 then
		createAfterimage(leftWing)
		createAfterimage(rightWing)
		timeSinceAfterimage = 0
	end
end)
