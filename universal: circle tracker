local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")

local segmentCount = 16 -- longer tail for smooth curve

-- Cleanup old parts
local crownFolder = workspace:FindFirstChild("VisualizerCrown")
if crownFolder then
    crownFolder:Destroy()
end
crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerCrown"
crownFolder.Parent = workspace

local parts = {}

local basePartThickness = 0.15
local basePartLength = 2

-- Create parts
for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Name = "TailPart"..i
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Transparency = 0
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Parent = crownFolder
    parts[i] = part
end

-- Set sizes
for i = 1, 10 do
    parts[i].Size = Vector3.new(basePartThickness, basePartThickness, basePartLength) -- tail segments
end

local squareThickness = basePartThickness
local squareLength = basePartLength * 1.2

-- Square tip frame parts (11-14)
parts[11].Size = Vector3.new(squareLength, squareThickness, squareThickness)  -- top
parts[12].Size = Vector3.new(squareThickness, squareThickness, squareLength)  -- right
parts[13].Size = Vector3.new(squareLength, squareThickness, squareThickness)  -- bottom
parts[14].Size = Vector3.new(squareThickness, squareThickness, squareLength)  -- left

-- Crossing parts near tip (15,16)
parts[15].Size = Vector3.new(squareThickness * 0.5, squareThickness * 0.5, squareLength * 0.9)
parts[15].Color = Color3.new(1, 0, 0)
parts[16].Size = Vector3.new(squareThickness * 0.5, squareThickness * 0.5, squareLength * 0.9)
parts[16].Color = Color3.new(1, 0, 0)

local wobbleTime = 0

RunService.Heartbeat:Connect(function(dt)
    wobbleTime = wobbleTime + dt * 5

    -- Base position at torso back waist
    local backWaistOffset = Vector3.new(0, -torso.Size.Y/2, torso.Size.Z/2)
    local baseCFrame = torso.CFrame * CFrame.new(backWaistOffset)

    -- Tail segments 1-10, extend backward (-Z torso)
    for i = 1, 10 do
        local offsetZ = -basePartLength * (i - 1)
        local swayX = math.sin(wobbleTime + i * 0.5) * 0.15
        local swayY = math.cos(wobbleTime * 1.5 + i * 0.8) * 0.05
        local localOffset = Vector3.new(swayX, swayY - 0.1 * i, offsetZ)
        local worldPos = baseCFrame:PointToWorldSpace(localOffset)

        -- The base orientation facing backward along -Z in torso space
        local wobbleRotation = CFrame.Angles(math.rad(swayY * 10), 0, math.rad(swayX * 20))

        -- Compose final CFrame: position + torso rotation + wobble rotation
        parts[i].CFrame = CFrame.new(worldPos) * baseCFrame - baseCFrame.Position * CFrame.new() * wobbleRotation

        -- CORRECT WAY:
        -- We want part's rotation to match torso rotation * wobbleRotation
        -- So we do:
        parts[i].CFrame = CFrame.new(worldPos) * baseCFrame.Rotation * wobbleRotation
    end

    -- Square tip parts 11-14 positioned after segment 10
    local tipLocalPos = Vector3.new(0, -0.1, -basePartLength * 10)
    local tipCFrame = baseCFrame * CFrame.new(tipLocalPos)

    local halfLen = squareLength / 2

    -- Top side (11): offset +X, no rotation
    parts[11].CFrame = tipCFrame * CFrame.new(halfLen, 0, 0)

    -- Right side (12): offset +Z, rotated 90° Y
    parts[12].CFrame = tipCFrame * CFrame.new(0, 0, halfLen) * CFrame.Angles(0, math.rad(90), 0)

    -- Bottom side (13): offset -X, no rotation
    parts[13].CFrame = tipCFrame * CFrame.new(-halfLen, 0, 0)

    -- Left side (14): offset -Z, rotated 90° Y
    parts[14].CFrame = tipCFrame * CFrame.new(0, 0, -halfLen) * CFrame.Angles(0, math.rad(90), 0)

    -- Crossing parts (15 and 16) intersect near square center
    parts[15].CFrame = tipCFrame * CFrame.Angles(math.rad(45), 0, 0)
    parts[16].CFrame = tipCFrame * CFrame.Angles(math.rad(-45), 0, 0)
end)
