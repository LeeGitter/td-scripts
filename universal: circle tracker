local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local head = character:WaitForChild("Head")

-- Tail settings
local TAIL_SEGMENTS = 16
local tailParts = {}
local tailRadius = 1
local tailLength = 0.75

-- Crown settings
local crownParts = {}
local CROWN_RADIUS = 4
local CROWN_PARTS = 12

-- Hop cooldown and state
local hopCooldown = false
local isAirborne = false

-- Afterimage function
local function spawnAfterImage()
	local clone = character:Clone()
	clone.Name = "AfterImage"
	for _, descendant in pairs(clone:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Anchored = true
			descendant.CanCollide = false
			descendant.Material = Enum.Material.Neon
			descendant.Color = Color3.fromHSV(tick() % 5 / 5, 0.5, 1)
		elseif descendant:IsA("Humanoid") then
			descendant:Destroy()
		end
	end
	clone.Parent = workspace
	game:GetService("Debris"):AddItem(clone, 0.4)
end

-- Hop logic
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.Space or hopCooldown then return end
	hopCooldown = true

	-- Play animation
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://125869734469543"
	local track = humanoid:LoadAnimation(anim)
	track.Priority = Enum.AnimationPriority.Action
	track:Play()
	task.delay(0.15, function()
		if track then track:Stop() end
	end)

	-- Launch upward & forward
	local bodyVel = Instance.new("BodyVelocity")
	bodyVel.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	bodyVel.Velocity = (hrp.CFrame.LookVector * 50 + Vector3.new(0, 20, 0))
	bodyVel.Parent = hrp
	isAirborne = true
	spawnAfterImage()
	task.delay(0.1, function()
		bodyVel:Destroy()
	end)

	-- Stop afterimages after landing
	task.delay(0.3, function()
		isAirborne = false
	end)

	task.delay(0.5, function()
		hopCooldown = false
	end)
end)

-- Tail setup
for i = 1, TAIL_SEGMENTS do
	local p = Instance.new("Part")
	p.Size = Vector3.new(0.5, 0.5, 0.5)
	p.Shape = Enum.PartType.Ball
	p.Material = Enum.Material.Neon
	p.Anchored = true
	p.CanCollide = false
	p.Color = Color3.fromHSV(i / TAIL_SEGMENTS, 1, 1)
	p.Parent = workspace
	table.insert(tailParts, p)
end

-- Special pastel cube at tip
local pastelCube = Instance.new("Part")
pastelCube.Size = Vector3.new(0.6, 0.6, 0.6)
pastelCube.Shape = Enum.PartType.Block
pastelCube.Material = Enum.Material.Neon
pastelCube.Anchored = true
pastelCube.CanCollide = false
pastelCube.Color = Color3.new(1, 1, 1)
pastelCube.Parent = workspace

-- Crown setup
for i = 1, CROWN_PARTS do
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.5, 2.5, 0.5)
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.CanCollide = false
	part.Parent = workspace
	table.insert(crownParts, part)
end

-- Tail & Crown update
RunService.RenderStepped:Connect(function(dt)
	local baseCFrame = hrp.CFrame
	local prevPos = baseCFrame.Position

	for i, part in ipairs(tailParts) do
		local t = tick() + i
		local offset = Vector3.new(
			math.sin(t * 2) * 0.4,
			math.cos(t * 2) * 0.4,
			-i * tailLength
		)
		local worldPos = baseCFrame.Position + baseCFrame:VectorToWorldSpace(offset)
		part.Position = part.Position:Lerp(worldPos, 0.5)
	end

	-- White pastel cube at tip (offset -5 studs behind tail tip)
	local tip = tailParts[#tailParts]
	local offsetDir = (tip.Position - tailParts[#tailParts - 1].Position).Unit
	pastelCube.Position = tip.Position + offsetDir * -5
	pastelCube.Color = Color3.fromHSV(tick() % 6 / 6, 0.4, 1)
	pastelCube.Orientation += Vector3.new(0, 3, 1)

	-- Crown logic
	local soundLevel = SoundService:GetService("SoundService").AmbientReverb
	for i, part in ipairs(crownParts) do
		local angle = math.rad((360 / #crownParts) * i)
		local height = math.sin(tick() * 3 + i) * 3 + 4
		local radius = CROWN_RADIUS + math.sin(tick() * 2 + i) * 1.2
		local offset = Vector3.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
		part.Position = head.Position + offset
		part.Color = Color3.fromHSV((tick() + i / #crownParts) % 1, 1, 1)
	end

	-- Afterimage trail if airborne
	if isAirborne then
		spawnAfterImage()
	end
end)
