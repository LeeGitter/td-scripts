local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")

-- Settings
local NUM_SEGMENTS = 16
local BASE_SIZE = Vector3.new(0.5, 0.5, 0.5)
local LENGTH_PER_SEGMENT = 0.7
local START_OFFSET = Vector3.new(0, 0.5, 1.5) -- Up and back offset relative to torso
local BUILD_DELAY = 0.15 -- Seconds between segments spawning

local segments = {}
local tailRootAttachment = nil
local cube = nil

-- Clean up old tail if exists
if character:FindFirstChild("TailRoot") then
	character.TailRoot:Destroy()
end

-- Create a root attachment on torso (for constraints)
tailRootAttachment = Instance.new("Attachment")
tailRootAttachment.Name = "TailRoot"
tailRootAttachment.Position = START_OFFSET
tailRootAttachment.Parent = torso

-- Helper function to create a tail segment
local function createSegment(index, parentAttachment)
	local part = Instance.new("Part")
	part.Name = "TailSegment_" .. index
	part.Size = BASE_SIZE + Vector3.new(index * 0.05, index * 0.05, LENGTH_PER_SEGMENT)
	part.Color = Color3.fromHSV((index / NUM_SEGMENTS) % 1, 1, 1) -- rainbow colors
	part.Material = Enum.Material.Neon
	part.CanCollide = false
	part.Anchored = false
	part.Massless = true
	part.CastShadow = false
	part.Parent = workspace

	local att1 = Instance.new("Attachment", part)
	local att2 = Instance.new("Attachment", parentAttachment.Parent)

	-- Position attachments for ball socket
	att1.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)
	att2.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	-- Constraint to connect this segment to parent
	local ballSocket = Instance.new("BallSocketConstraint")
	ballSocket.Attachment0 = att2
	ballSocket.Attachment1 = att1
	ballSocket.LimitsEnabled = true
	ballSocket.TwistLimitsEnabled = true
	ballSocket.UpperAngle = 25
	ballSocket.TwistLowerAngle = -15
	ballSocket.TwistUpperAngle = 15
	ballSocket.Parent = part

	return part, att1
end

-- Coroutine to build tail gradually
coroutine.wrap(function()
	local lastAttachment = tailRootAttachment

	for i = 1, NUM_SEGMENTS do
		local segment, newAttachment = createSegment(i, lastAttachment)
		table.insert(segments, segment)
		lastAttachment = newAttachment

		-- Position segment initially relative to torso + offset + length * i
		segment.CFrame = torso.CFrame * CFrame.new(-START_OFFSET.X, START_OFFSET.Y, -START_OFFSET.Z - LENGTH_PER_SEGMENT * i)
		
		wait(BUILD_DELAY)
	end

	-- Now create the cube at the tail tip
	cube = Instance.new("Part")
	cube.Shape = Enum.PartType.Block
	cube.Size = Vector3.new(1.5, 1.5, 1.5)
	cube.Material = Enum.Material.Neon
	cube.Color = Color3.fromRGB(255, 255, 100)
	cube.Anchored = false
	cube.CanCollide = false
	cube.Massless = true
	cube.Parent = workspace

	local attachTail = Instance.new("Attachment", segments[#segments])
	attachTail.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local attachCube = Instance.new("Attachment", cube)
	attachCube.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	local hinge = Instance.new("HingeConstraint")
	hinge.Attachment0 = attachTail
	hinge.Attachment1 = attachCube
	hinge.Parent = cube
	hinge.MotorMaxTorque = math.huge
	hinge.AngularVelocity = 5
end)()

-- Movement-based wiggling
local lastPos = torso.Position
RunService.RenderStepped:Connect(function()
	if #segments == 0 then return end -- Wait until tail is built
	
	local moveVec = (torso.Position - lastPos)
	lastPos = torso.Position

	for i, part in ipairs(segments) do
		local phase = tick() * 2 + i
		local sway = math.sin(phase) * (moveVec.Magnitude * 5)
		local offset = Vector3.new(sway * 0.05, 0, 0)
		part.AssemblyLinearVelocity = offset
	end

	if cube then
		cube.RotVelocity = Vector3.new(2, 4, 1) -- Independent wobble/spin
	end
end)
