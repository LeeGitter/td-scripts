local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Tail config
local tailParts = {}
local tailLength = 16
local partDistance = 1.25
local buildDelay = 0.05

-- White cube config
local whiteCubeOffset = Vector3.new(0, 0, -6)
local whiteCube = nil
local idleTime = 0
local tailBuilt = false

-- Utility: Creates a tail segment
local function createTailPart(index)
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.8, 0.8, 0.8)
	part.Shape = Enum.PartType.Ball
	part.Material = Enum.Material.SmoothPlastic
	part.Color = Color3.fromRGB(80, 170, 255)
	part.CanCollide = false
	part.Anchored = true
	part.Transparency = 0
	part.Name = "TailPart_" .. index
	part.Parent = workspace
	return part
end

-- Creates the white cube tip
local function createWhiteCube()
	local part = Instance.new("Part")
	part.Size = Vector3.new(1.4, 1.4, 1.4)
	part.Shape = Enum.PartType.Block
	part.Material = Enum.Material.SmoothPlastic
	part.Anchored = true
	part.CanCollide = false
	part.BrickColor = BrickColor.White()
	part.Name = "TailCube"
	part.Parent = workspace

	local glow = Instance.new("PointLight")
	glow.Color = Color3.new(1, 1, 1)
	glow.Brightness = 2
	glow.Range = 6
	glow.Parent = part

	return part
end

-- Build the tail slowly
task.spawn(function()
	for i = 1, tailLength do
		local part = createTailPart(i)
		table.insert(tailParts, part)
		task.wait(buildDelay)
	end

	tailBuilt = true

	-- Spawn white cube after tail is done
	whiteCube = createWhiteCube()
end)

-- Update loop
RunService.RenderStepped:Connect(function(dt)
	if not tailBuilt then return end

	local speed = (hrp.Velocity * Vector3.new(1, 0, 1)).Magnitude
	if speed < 1 then
		idleTime += dt
	else
		idleTime = 0
	end

	-- Tail positioning
	for i, part in ipairs(tailParts) do
		local t = i / tailLength
		local offset = Vector3.new(0, math.sin(t * math.pi) * 2, -i * partDistance)
		local baseCF = hrp.CFrame * CFrame.new(0, -1, 0)
		local finalPos = baseCF.Position + baseCF.LookVector * offset.Z + baseCF.UpVector * offset.Y

		-- Less wobble on sharp turns
		local wobble = Vector3.new(
			math.sin(tick() * 3 + i) * 0.1,
			math.sin(tick() * 4 + i) * 0.1,
			0
		)

		if idleTime > 4 then
			local randomStyle = math.sin(tick() * 2 + i) * 2
			wobble += Vector3.new(0, math.sin(tick() * 6 + i) * 0.3 + randomStyle * 0.1, 0)
		end

		part.Position = finalPos + wobble
	end

	-- White cube positioning
	if whiteCube and tailParts[#tailParts] then
		local tip = tailParts[#tailParts]
		local tipCF = CFrame.new(tip.Position, hrp.Position)
		local cubeOffset = tipCF:VectorToWorldSpace(whiteCubeOffset)
		whiteCube.Position = tip.Position + cubeOffset

		-- Color shift
		local h = (tick() * 0.2) % 1
		local s = 0.5
		local v = 1
		whiteCube.Color = Color3.fromHSV(h, s, v)

		-- Rotation
		whiteCube.Orientation += Vector3.new(1, 2, 1.5)
	end
end)
