local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local torso = character:WaitForChild("Torso")
local head = character:WaitForChild("Head")

-------------------------------
-- Tail Configuration (unchanged)
-------------------------------
local NUM_SEGMENTS = 16
local BASE_SIZE = Vector3.new(0.5, 0.5, 0.7)
local LENGTH_PER_SEGMENT = 0.7
local BASE_OFFSET = Vector3.new(0, -1.5, 1.5)
local MAX_PITCH_ANGLE = math.rad(30)
local BUILD_DELAY = 0.05

if character:FindFirstChild("DynamicTailModel") then
	character.DynamicTailModel:Destroy()
end

local tailModel = Instance.new("Model")
tailModel.Name = "DynamicTailModel"
tailModel.Parent = character

local tailRootAttachment = Instance.new("Attachment")
tailRootAttachment.Name = "TailRootAttachment"
tailRootAttachment.Position = BASE_OFFSET
tailRootAttachment.Parent = torso

local segments, attachments = {}, {}

local function createSegment(index)
	local part = Instance.new("Part")
	part.Name = "TailSegment_" .. index
	local sizeMultiplier = 1 + (index / NUM_SEGMENTS) * 1.5
	part.Size = Vector3.new(BASE_SIZE.X * sizeMultiplier, BASE_SIZE.Y * sizeMultiplier, LENGTH_PER_SEGMENT)
	part.Material = Enum.Material.Neon
	part.Anchored = false
	part.CanCollide = false
	part.Massless = true
	part.CastShadow = false
	part.Color = Color3.fromHSV((index / NUM_SEGMENTS) % 1, 1, 1)
	part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	part.Parent = tailModel

	local att0 = Instance.new("Attachment", part)
	att0.Name = "Attachment0"
	att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local att1 = Instance.new("Attachment", part)
	att1.Name = "Attachment1"
	att1.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	return part, att0, att1
end

for i = 1, NUM_SEGMENTS do
	local part, att0, att1 = createSegment(i)
	segments[i] = part
	attachments[i] = {att0, att1}
	local t = (i - 1) / (NUM_SEGMENTS - 1)
	local pitchAngle = MAX_PITCH_ANGLE * t
	local basePos = Vector3.new(0, BASE_OFFSET.Y, -BASE_OFFSET.Z - LENGTH_PER_SEGMENT * (i - 1))
	local cframe = torso.CFrame * CFrame.new(basePos) * CFrame.Angles(pitchAngle, 0, 0)
	part.CFrame = cframe
	part.Anchored = true
	wait(BUILD_DELAY)
end

for i = 1, NUM_SEGMENTS do
	local part = segments[i]
	part.Anchored = false
	local att0, att1 = attachments[i][1], attachments[i][2]
	local attachA = (i == 1) and tailRootAttachment or attachments[i - 1][2]
	local attachB = att0

	local alignPos = Instance.new("AlignPosition")
	alignPos.Attachment0 = attachB
	alignPos.Attachment1 = attachA
	alignPos.MaxForce = 10000
	alignPos.Responsiveness = 50
	alignPos.RigidityEnabled = false
	alignPos.Parent = part

	local alignOri = Instance.new("AlignOrientation")
	alignOri.Attachment0 = attachB
	alignOri.Attachment1 = attachA
	alignOri.MaxTorque = 10000
	alignOri.Responsiveness = 50
	alignOri.Parent = part
end

local wobbleSpeed = 2
local wobbleMagnitude = 0.05

RunService.RenderStepped:Connect(function()
	local velocity = torso.Velocity.Magnitude
	local time = tick()
	for i, part in ipairs(segments) do
		local phase = time * wobbleSpeed + i
		local swayX = math.sin(phase) * wobbleMagnitude * (velocity / 20)
		local swayY = math.cos(phase * 1.5) * wobbleMagnitude * (velocity / 20)
		local att0, att1 = attachments[i][1], attachments[i][2]
		att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2) + Vector3.new(swayX, swayY, 0)
	end
end)

-------------------------------
-- Crown Configuration (unchanged)
-------------------------------
local segmentCount = 10
local radius = 2
local heightOffset = 3
local basePartSize = Vector3.new(0.3, 0.5, 0.3)
local soundDetectionRadius = 60
local maxLoudnessExpected = 1000
local maxPartHeight = 5

-- Clear existing crown folder if any
local crownFolder = workspace:FindFirstChild("VisualizerCrown")
if crownFolder then
    crownFolder:Destroy()
end
crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerCrown"
crownFolder.Parent = workspace

local parts = {}
local partScales = {}

for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = basePartSize
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Transparency = 0
    part.Name = "CrownPart"..i
    part.Parent = crownFolder
    parts[i] = part
    partScales[i] = basePartSize.Y
end

-- Smooth tilt + wobble
local prevTiltX, prevTiltZ = 0, 0
local tiltSmoothing = 0.1
local tiltIntensity = 0.1
local wobbleDuration = 0.5
local wobbleTime = 0
local wobbleAmplitudePos = 0.2
local wobbleAmplitudeRot = 0.09
local wobbleActive = false
local lastPitch, lastRoll = 0, 0
local wobbleTriggerThreshold = 0.05

-- Highlight
local highlight = nil
local highlightTime = 0
local highlightDuration = 1.0
local highlightFullyVisibleTime = 0.2
local rainbowCycleDuration = 0.5

-- Get 3D position of sound
local function getSoundPosition(sound)
    if sound.Parent:IsA("BasePart") then
        return sound.Parent.Position
    elseif sound.Parent:IsA("Model") then
        local hrp = sound.Parent:FindFirstChild("HumanoidRootPart")
        if hrp then return hrp.Position end
        for _, d in pairs(sound.Parent:GetDescendants()) do
            if d:IsA("BasePart") then return d.Position end
        end
    end
    return head.Position
end

-- Cached sounds list and throttle timer
local cachedSounds = {}
local timeSinceLastScan = 0
local scanInterval = 0.1 -- seconds

-- Detect all nearby sounds and flag floating/global ones (throttled)
local function getNearbySounds(dt)
    timeSinceLastScan = timeSinceLastScan + dt
    if timeSinceLastScan < scanInterval then
        return cachedSounds
    end
    timeSinceLastScan = 0

    local sounds = {}

    for _, sound in pairs(workspace:GetDescendants()) do
        if sound:IsA("Sound") and sound.IsPlaying then
            local pos = getSoundPosition(sound)
            if (pos - head.Position).Magnitude <= soundDetectionRadius then
                local isFloating = not sound.Parent:IsA("BasePart") and not sound.Parent:IsA("Model")
                table.insert(sounds, {
                    Instance = sound,
                    IsFloating = isFloating
                })
            end
        end
    end

    local function addLocalSounds(root)
        for _, sound in pairs(root:GetDescendants()) do
            if sound:IsA("Sound") and sound.IsPlaying then
                table.insert(sounds, {
                    Instance = sound,
                    IsFloating = false
                })
            end
        end
    end

    addLocalSounds(player:WaitForChild("PlayerGui"))
    addLocalSounds(character)

    cachedSounds = sounds
    return sounds
end

-- Highlight setup
local function createHighlight()
    if highlight then return end
    highlight = Instance.new("SelectionBox")
    highlight.Adornee = character
    highlight.Parent = character
    highlight.LineThickness = 0.05
    highlight.Transparency = 0
    highlight.Color3 = Color3.new(1,1,1)
    highlight.SurfaceTransparency = 0.8
end

local function removeHighlight()
    if highlight then
        highlight:Destroy()
        highlight = nil
    end
end

-------------------------------
-- Afterimage + Speed Boost Variables
-------------------------------
local ACTIVE_THRESHOLD = 0.4 -- 40% of max height
local ACTIVE_TIME_REQUIRED = 4 -- seconds
local afterimageFadeTime = 0.4

local activeTimer = 0
local afterimagesEnabled = false

local afterimageFolder = Instance.new("Folder")
afterimageFolder.Name = "Afterimages"
afterimageFolder.Parent = workspace

local afterimageCleanup = {}

local function createAfterimage()
    -- Create a transparent clone of the character parts with pastel rainbow colors, fading out over afterimageFadeTime
    local clone = Instance.new("Model")
    clone.Name = "AfterimageClone"
    clone.Parent = afterimageFolder

    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            local clonedPart = part:Clone()
            clonedPart.Anchored = true
            clonedPart.CanCollide = false
            clonedPart.Massless = true
            clonedPart.Parent = clone

            -- Pastel rainbow color based on time and part index
            local hue = (tick() * 2 + #clone:GetChildren()) % 1
            local pastelColor = Color3.fromHSV(hue, 0.6, 1)

            clonedPart.Color = pastelColor
            clonedPart.Material = Enum.Material.Neon
            clonedPart.Transparency = 0.6

            -- Match current CFrame
            clonedPart.CFrame = part.CFrame
        elseif part:IsA("Accessory") then
            local accessoryClone = part:Clone()
            accessoryClone.Parent = clone
        end
    end

    -- Schedule fade and cleanup
    local startTime = tick()
    table.insert(afterimageCleanup, {
        Model = clone,
        StartTime = startTime
    })
end

local function cleanupAfterimages()
    local now = tick()
    for i = #afterimageCleanup, 1, -1 do
        local data = afterimageCleanup[i]
        local elapsed = now - data.StartTime
        local progress = elapsed / afterimageFadeTime
        if progress >= 1 then
            data.Model:Destroy()
            table.remove(afterimageCleanup, i)
        else
            -- Fade out the parts
            for _, part in pairs(data.Model:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Transparency = 0.6 + progress * 0.4
                end
            end
        end
    end
end

-- Speed spoofing state
local speedBoostMultiplier = 1.10
local speedSpoofActive = false

local function applySpeedBoost(dt)
    if not speedSpoofActive then return end
    -- Multiply humanoid WalkSpeed gently, clamp max speed to avoid runaway speed
    local currentSpeed = humanoid.WalkSpeed
    local newSpeed = math.min(currentSpeed * speedBoostMultiplier, 1000)
    humanoid.WalkSpeed = newSpeed
end

local function resetSpeed()
    -- To remove speed boost, just set WalkSpeed to default value 16 (or something you prefer)
    -- But since you want to spoof speed without knowing base, instead reduce speed gradually to default 16
    -- We'll slowly lerp speed down to 16 when boost ends
    speedSpoofActive = false
end

local function slowSpeedReset(dt)
    if speedSpoofActive then return end
    if humanoid.WalkSpeed <= 16 then
        humanoid.WalkSpeed = 16
    else
        humanoid.WalkSpeed = humanoid.WalkSpeed - 2 * dt * 60 -- smooth decrease (adjust speed here)
        if humanoid.WalkSpeed < 16 then humanoid.WalkSpeed = 16 end
    end
end

-------------------------------
-- Main Heartbeat Loop
-------------------------------
RunService.Heartbeat:Connect(function(dt)
    local headCFrame = head.CFrame
    local pitch, roll = headCFrame:ToEulerAnglesXYZ()

    if math.abs(pitch - lastPitch) > wobbleTriggerThreshold or math.abs(roll - lastRoll) > wobbleTriggerThreshold then
        wobbleActive = true
        wobbleTime = 0
    end
    lastPitch, lastRoll = pitch, roll

    local targetTiltX = -pitch * tiltIntensity
    local targetTiltZ = -roll * tiltIntensity
    prevTiltX += (targetTiltX - prevTiltX) * tiltSmoothing
    prevTiltZ += (targetTiltZ - prevTiltZ) * tiltSmoothing

    if wobbleActive then
        wobbleTime += dt
        if wobbleTime > wobbleDuration then
            wobbleActive = false
            wobbleTime = wobbleDuration
        end
    end

    local wobbleProgress = wobbleTime / wobbleDuration
    local wobblePosOffset = 0
    local wobbleRotOffset =
