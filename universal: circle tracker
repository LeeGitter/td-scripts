local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local soundDetectionRadius = 100
local totalParts = 6
local localPartCount = 3
local globalPartCount = totalParts - localPartCount
local radius = 12

local partHeight = 2
local baseSize = Vector3.new(1, partHeight, 1)

local parts = {}

local function createPart(color)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = baseSize
	part.Shape = Enum.PartType.Cylinder
	part.Material = Enum.Material.Neon
	part.Color = color
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	part.Parent = workspace
	return part
end

for i = 1, totalParts do
	local color = i <= localPartCount and Color3.fromRGB(50, 200, 255) or Color3.fromRGB(255, 50, 100)
	table.insert(parts, createPart(color))
end

-- Helper to determine position of 3D sounds
local function getSoundPosition(sound)
	if sound:IsDescendantOf(workspace) and sound.Parent:IsA("BasePart") then
		return sound.Parent.Position
	elseif sound:IsDescendantOf(workspace) and sound.Parent:IsA("Model") then
		local model = sound.Parent
		if model.PrimaryPart then
			return model.PrimaryPart.Position
		else
			local total = Vector3.zero
			local count = 0
			for _, p in ipairs(model:GetDescendants()) do
				if p:IsA("BasePart") then
					total += p.Position
					count += 1
				end
			end
			return count > 0 and total / count or Vector3.zero
		end
	end
	return Vector3.zero
end

-- Scan for playing sounds
local function getNearbySounds()
	local sounds = {}

	-- Global/world sounds
	for _, sound in ipairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.IsPlaying then
			local pos = getSoundPosition(sound)
			local dist = (pos - head.Position).Magnitude
			if dist <= soundDetectionRadius then
				local isFloating = not sound.Parent:IsA("BasePart") and not sound.Parent:IsA("Model")
				table.insert(sounds, {
					Instance = sound,
					Distance = dist,
					IsFloating = isFloating,
					IsLocal = false
				})
			end
		end
	end

	-- Local sounds from character and PlayerGui
	local function addLocal(root)
		for _, sound in ipairs(root:GetDescendants()) do
			if sound:IsA("Sound") and sound.IsPlaying then
				table.insert(sounds, {
					Instance = sound,
					Distance = 0,
					IsFloating = false,
					IsLocal = true
				})
			end
		end
	end

	addLocal(character)
	addLocal(player:WaitForChild("PlayerGui"))

	return sounds
end

-- Assign sounds to part indices
local function assignSoundsToParts(sounds)
	local assigned = table.create(totalParts)
	for _, s in ipairs(sounds) do
		local targetIndex
		if s.IsLocal then
			targetIndex = math.random(1, localPartCount)
		else
			targetIndex = math.random(localPartCount + 1, totalParts)
		end
		assigned[targetIndex] = assigned[targetIndex] or s
	end
	return assigned
end

-- More sensitive easing
local function getAdjustedLoudness(raw, isFloating)
	raw = raw or 0
	local sensitivityBoost = isFloating and 3 or 2
	local normalized = math.clamp(raw / 150, 0, 1)  -- 150 can be adjusted
	return (normalized ^ 0.5) * sensitivityBoost
end

-- Main render loop
RunService.Heartbeat:Connect(function()
	local sounds = getNearbySounds()
	local soundMap = assignSoundsToParts(sounds)

	local cameraCF = workspace.CurrentCamera.CFrame
	local right = cameraCF.RightVector
	local forward = cameraCF.LookVector

	for i, part in ipairs(parts) do
		local angle = (math.pi * 2 / totalParts) * (i - 1)
		local offset = (right * math.cos(angle) + forward * math.sin(angle)) * radius
		local position = head.Position + Vector3.new(0, 4, 0) + offset

		local soundData = soundMap[i]
		local loudness = 0

		if soundData and soundData.Instance then
			local s = soundData.Instance
			loudness = getAdjustedLoudness(s.PlaybackLoudness, soundData.IsFloating)
		end

		local scale = math.clamp(loudness * 2, 0.2, 6)
		part.Size = Vector3.new(scale, partHeight, scale)
		part.CFrame = CFrame.new(position, position + Vector3.new(0, 1, 0)) * CFrame.Angles(0, 0, math.rad(90))
	end
end)
