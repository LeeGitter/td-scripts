local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- Settings
local SEGMENT_COUNT = 16
local SEGMENT_DISTANCE = 1
local SEGMENT_SIZE_MIN = Vector3.new(0.4, 0.4, 0.4)
local SEGMENT_SIZE_MAX = Vector3.new(1.5, 1.5, 1.5)
local IDLE_TIME_FOR_TWITCH = 4
local CUBE_OFFSET = 10

-- Tail storage
local segments = {}
local velocities = {}
local lastPos = root.Position
local idleTime = 0

-- Rainbow color function
local function getRainbowColor(t)
	local hue = (tick() * 0.2 + t) % 1
	return Color3.fromHSV(hue, 1, 1)
end

-- Create tail segments
for i = 1, SEGMENT_COUNT do
	local sizeScale = i / SEGMENT_COUNT
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Block
	part.Size = SEGMENT_SIZE_MIN:Lerp(SEGMENT_SIZE_MAX, sizeScale)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.SmoothPlastic
	part.Color = getRainbowColor(i / SEGMENT_COUNT)
	part.Transparency = 0
	part.Name = "TailSegment_" .. i
	part.Parent = workspace
	table.insert(segments, part)
	velocities[i] = Vector3.zero
end

-- White cube
local whiteCube = Instance.new("Part")
whiteCube.Shape = Enum.PartType.Block
whiteCube.Size = Vector3.new(1,1,1)
whiteCube.Anchored = true
whiteCube.CanCollide = false
whiteCube.Material = Enum.Material.Neon
whiteCube.Color = Color3.new(1,1,1)
whiteCube.Name = "TailCube"
whiteCube.Parent = workspace

-- Idle animation settings
local doingIdleAnim = false
local idleClock = 0

-- Main update loop
RunService.RenderStepped:Connect(function(dt)
	local currentPos = root.Position
	local moved = (currentPos - lastPos).Magnitude > 0.05

	if moved then
		idleTime = 0
		doingIdleAnim = false
	else
		idleTime += dt
	end

	-- Curl/helicopter animations when idle
	if idleTime >= IDLE_TIME_FOR_TWITCH and not doingIdleAnim then
		doingIdleAnim = true
		idleClock = 0
	end

	-- Position segments
	for i, segment in ipairs(segments) do
		local targetPos
		if i == 1 then
			targetPos = root.Position - root.CFrame.UpVector * 1.5
		else
			targetPos = segments[i - 1].Position - (segments[i - 1].CFrame.LookVector * SEGMENT_DISTANCE)
		end

		-- Wobble
		local wobble = Vector3.new(
			math.sin(tick() * 2 + i) * 0.2,
			math.cos(tick() * 1.8 + i * 1.2) * 0.15,
			math.sin(tick() * 2.5 + i * 0.5) * 0.2
		)

		if doingIdleAnim then
			idleClock += dt
			local mode = math.floor(idleClock) % 2
			if mode == 0 then
				-- Curl upward
				wobble += Vector3.new(0, math.sin(idleClock * 3 + i) * 0.3, 0)
			else
				-- Helicopter motion
				wobble += Vector3.new(
					math.sin(idleClock * 10 + i) * 0.3,
					0,
					math.cos(idleClock * 10 + i) * 0.3
				)
			end
		end

		local smoothFactor = moved and 0.2 or 0.08
		segment.Position = segment.Position:Lerp(targetPos + wobble, smoothFactor)
		segment.Color = getRainbowColor(i / SEGMENT_COUNT)
	end

	-- White cube positioning
	local tip = segments[#segments]
	local cubeOffsetDir = (tip.Position - segments[#segments - 1].Position).Unit
	local offsetPos = tip.Position + cubeOffsetDir * CUBE_OFFSET
	local cubeWobble = Vector3.new(
		math.sin(tick() * 4) * 0.5,
		math.cos(tick() * 3.3) * 0.5,
		math.sin(tick() * 5) * 0.5
	)

	whiteCube.Position = offsetPos + cubeWobble
	whiteCube.Orientation += Vector3.new(2, 3, 1) -- Passive spin
	whiteCube.Color = getRainbowColor(tick() * 0.1)

	lastPos = currentPos
end)
