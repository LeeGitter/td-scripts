local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")

-- SETTINGS
local crownRadius = 3
local numCrownParts = 12
local tailLength = 17
local partSizeIncrement = 0.15
local tailSpacing = 0.5
local trailDuration = 0.4
local pastelColors = {
	Color3.fromRGB(255, 200, 200),
	Color3.fromRGB(255, 235, 200),
	Color3.fromRGB(200, 255, 200),
	Color3.fromRGB(200, 255, 255),
	Color3.fromRGB(200, 200, 255),
	Color3.fromRGB(235, 200, 255)
}

-- CLEANUP
for _, obj in ipairs(char:GetChildren()) do
	if obj.Name == "RainbowCrown" or obj.Name == "RainbowTail" then
		obj:Destroy()
	end
end

-- Create folder
local crownFolder = Instance.new("Folder", char)
crownFolder.Name = "RainbowCrown"

-- Crown Part Creation
local crownParts = {}
for i = 1, numCrownParts do
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Block
	part.Size = Vector3.new(0.3, 0.3, 0.3)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = pastelColors[(i % #pastelColors) + 1]
	part.Parent = crownFolder
	table.insert(crownParts, part)
end

-- Tail
local tailFolder = Instance.new("Folder", char)
tailFolder.Name = "RainbowTail"

local tailParts = {}
for i = 1, tailLength do
	local part = Instance.new("Part")
	local size = 0.3 + (i * partSizeIncrement)
	part.Size = Vector3.new(size, size, size)
	part.Shape = Enum.PartType.Block
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.CanCollide = false
	part.Color = pastelColors[((i + 2) % #pastelColors) + 1]
	part.Parent = tailFolder
	table.insert(tailParts, part)
	task.wait(0.03)
end

-- White pastel cube at tail tip
local pastelCube = Instance.new("Part")
pastelCube.Size = Vector3.new(0.7, 0.7, 0.7)
pastelCube.Anchored = true
pastelCube.CanCollide = false
pastelCube.Material = Enum.Material.Neon
pastelCube.Color = Color3.fromRGB(255, 255, 255)
pastelCube.Parent = tailFolder

-- For tracking crown height
local crownHeightTimer = 0
local isBuffActive = false
local lastBuffCheck = tick()

-- Helper: Create afterimage
local function createAfterimage()
	local clone = char:Clone()
	for _, d in ipairs(clone:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			d.Transparency = 0.3
			d.Color = pastelColors[math.random(1, #pastelColors)]
			d.Material = Enum.Material.Neon
		elseif d:IsA("Humanoid") then
			d:Destroy()
		end
	end
	clone.Parent = workspace
	game:GetService("Debris"):AddItem(clone, trailDuration)
end

-- Movement check
local prevPos = hrp.Position
local lastMove = tick()

RunService.RenderStepped:Connect(function(dt)
	local time = tick()

	-- Update Crown
	for i, part in ipairs(crownParts) do
		local angle = math.rad((360 / numCrownParts) * i + (time * 50))
		local offset = Vector3.new(math.cos(angle), 1.8, math.sin(angle)) * crownRadius
		part.Position = hrp.Position + offset
	end

	-- Check crown height
	local highCount = 0
	for _, part in ipairs(crownParts) do
		if (part.Position.Y - hrp.Position.Y) >= (crownRadius * 0.4) then
			highCount += 1
		end
	end

	-- Handle buff and afterimage
	if highCount >= 1 then
		crownHeightTimer += dt
		if crownHeightTimer >= 4 and not isBuffActive then
			isBuffActive = true
		end
	else
		crownHeightTimer = 0
		isBuffActive = false
	end

	if isBuffActive then
		if (time - lastBuffCheck) > 0.05 then
			createAfterimage()
			lastBuffCheck = time
		end
	end

	-- Spoofed speed buff
	if isBuffActive then
		if humanoid then
			humanoid.WalkSpeed = 16 * 1.1
		end
	else
		if humanoid then
			humanoid.WalkSpeed = 16
		end
	end

	-- Update Tail
	local velocity = (hrp.Position - prevPos) / dt
	local speed = velocity.Magnitude
	prevPos = hrp.Position

	local basePos = hrp.Position - hrp.CFrame.LookVector * 1.5
	for i, part in ipairs(tailParts) do
		local offset = Vector3.new(0, -0.5, -i * tailSpacing)
		local targetPos = basePos + hrp.CFrame:VectorToWorldSpace(offset)
		local currentPos = part.Position
		part.Position = currentPos:Lerp(targetPos, math.clamp(dt * 5 / (speed + 2), 0.1, 0.9))
	end

	-- Pastel cube
	local tip = tailParts[#tailParts]
	local offset = tip.CFrame.LookVector * -5
	pastelCube.CFrame = tip.CFrame * CFrame.new(offset) * CFrame.Angles(0, time * 3, 0)
end)
