local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local head = char:WaitForChild("Head")
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")

-- CONFIG
local rainbowColors = {}
for i = 0, 360, 30 do
	table.insert(rainbowColors, Color3.fromHSV(i / 360, 1, 1))
end

local NUM_CROWN = 12
local TAIL_SEGMENTS = 14
local CROWN_RADIUS = 3
local CROWN_HEIGHT = 1.5

-- CLEANUP
for _, obj in ipairs(char:GetChildren()) do
	if obj.Name == "RainbowCrown" or obj.Name == "RainbowTail" then
		obj:Destroy()
	end
end

-- STORAGE
local crownFolder = Instance.new("Folder", char)
crownFolder.Name = "RainbowCrown"
local tailFolder = Instance.new("Folder", char)
tailFolder.Name = "RainbowTail"

local crownParts = {}
local tailParts = {}

-- CREATE CROWN BLOCKS
for i = 1, NUM_CROWN do
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.3, 1.2, 0.3)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = rainbowColors[i % #rainbowColors + 1]
	part.Name = "CrownPart"
	part.Parent = crownFolder
	table.insert(crownParts, part)
end

-- CREATE TAIL SEGMENTS
for i = 1, TAIL_SEGMENTS do
	local part = Instance.new("Part")
	local scale = 0.5 + (i / TAIL_SEGMENTS) * 1.2
	part.Size = Vector3.new(scale, scale, scale)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = rainbowColors[i % #rainbowColors + 1]
	part.Name = "TailSegment"
	part.Parent = tailFolder
	table.insert(tailParts, part)
end

-- AFTERIMAGE CREATION
local function createAfterimages()
	for i = 1, 5 do
		local ghost = char:Clone()
		ghost:PivotTo(char:GetPivot())
		for _, d in ghost:GetDescendants() do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
				d.Material = Enum.Material.Neon
				d.Transparency = 0.75
			elseif d:IsA("Humanoid") then
				d:Destroy()
			end
		end
		ghost.Parent = workspace
		Debris:AddItem(ghost, 0.3 + i * 0.03)
		task.wait(0.03)
	end
end

-- JUMP DETECTION
humanoid.StateChanged:Connect(function(old, new)
	if new == Enum.HumanoidStateType.Jumping then
		createAfterimages()
	end
end)

-- AUDIO LEVEL CHECK
local loudness = 0
RunService.Stepped:Connect(function()
	local total = 0
	for _, s in head:GetDescendants() do
		if s:IsA("Sound") and s.IsPlaying then
			total += s.PlaybackLoudness or 0
		end
	end
	for _, s in SoundService:GetDescendants() do
		if s:IsA("Sound") and s.IsPlaying then
			total += (s.PlaybackLoudness or 0) * 0.3
		end
	end
	loudness = total
end)

-- UPDATE LOOP
local lastTailPositions = {}

RunService.RenderStepped:Connect(function(dt)
	local t = tick()

	-- Update Crown
	for i, part in ipairs(crownParts) do
		local angle = math.rad((360 / NUM_CROWN) * i + t * 60)
		local localUp = head.CFrame:VectorToWorldSpace(Vector3.new(0, 1, 0))
		local offset = Vector3.new(math.cos(angle), 0, math.sin(angle)) * CROWN_RADIUS
		local worldPos = head.Position + localUp * CROWN_HEIGHT + offset
		local scale = 1 + (loudness / 500) -- boost with audio
		part.Size = Vector3.new(0.3, 1.2 * scale, 0.3)
		part.CFrame = CFrame.lookAt(worldPos, head.Position) * CFrame.Angles(0, 0, math.sin(t * 2 + i) * 0.2)
	end

	-- Update Tail
	local prevPos = hrp.Position
	for i, part in ipairs(tailParts) do
		if lastTailPositions[i] then
			part.Position = part.Position:Lerp(lastTailPositions[i], dt * 15)
		else
			part.Position = prevPos
		end
		lastTailPositions[i] = prevPos
		prevPos = part.Position
	end
end)
