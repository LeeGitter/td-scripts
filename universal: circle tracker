local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")

local segmentCount = 16

local crownFolder = workspace:FindFirstChild("VisualizerTail")
if crownFolder then crownFolder:Destroy() end

crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerTail"
crownFolder.Parent = workspace

local parts = {}

local basePartThickness = 0.15
local basePartLength = 2

-- Create tail parts
for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Name = "TailPart"..i
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Transparency = 0
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Parent = crownFolder
    parts[i] = part
end

-- Set sizes for tail segments 1-10
for i = 1, 10 do
    parts[i].Size = Vector3.new(basePartThickness, basePartThickness, basePartLength)
end

-- Set sizes for square tip parts 11-14
local squareThickness = basePartThickness
local squareLength = basePartLength * 1.2

parts[11].Size = Vector3.new(squareLength, squareThickness, squareThickness)  -- top
parts[12].Size = Vector3.new(squareThickness, squareThickness, squareLength)  -- right
parts[13].Size = Vector3.new(squareLength, squareThickness, squareThickness)  -- bottom
parts[14].Size = Vector3.new(squareThickness, squareThickness, squareLength)  -- left

-- Crossing parts 15 and 16 near tip
parts[15].Size = Vector3.new(squareThickness * 0.5, squareThickness * 0.5, squareLength * 0.9)
parts[15].Color = Color3.new(1, 0, 0)
parts[16].Size = Vector3.new(squareThickness * 0.5, squareThickness * 0.5, squareLength * 0.9)
parts[16].Color = Color3.new(1, 0, 0)

local wobbleTime = 0

RunService.Heartbeat:Connect(function(dt)
    wobbleTime = wobbleTime + dt * 5

    local torsoPos = torso.Position
    local backward = -torso.CFrame.LookVector

    -- Base waist position (torso position lowered by half torso height)
    local basePos = torsoPos + Vector3.new(0, -torso.Size.Y/2, 0)

    -- Tail segments 1-10
    for i = 1, 10 do
        local offsetLength = basePartLength * (i - 1)
        local swayX = math.sin(wobbleTime + i * 0.5) * 0.15
        local swayY = math.cos(wobbleTime * 1.5 + i * 0.8) * 0.05
        local verticalDrop = -0.1 * i

        -- Calculate local wobble offset in world space:
        -- We take torso's right and up vectors to apply swayX/Y properly
        local rightVec = torso.CFrame.RightVector
        local upVec = Vector3.new(0, 1, 0)

        local wobbleOffset = rightVec * swayX + upVec * (swayY + verticalDrop)

        -- Final world position for this segment:
        local partPos = basePos + backward * offsetLength + wobbleOffset

        parts[i].CFrame = CFrame.new(partPos, partPos + backward)
    end

    -- Square tip parts 11-14, positioned after segment 10
    local tipBasePos = basePos + backward * (basePartLength * 10) + Vector3.new(0, -0.1, 0)

    local halfLen = squareLength / 2

    -- top side (11): offset +X
    parts[11].CFrame = CFrame.new(tipBasePos + torso.CFrame.RightVector * halfLen, tipBasePos + backward)

    -- right side (12): offset +Z, rotated 90°
    parts[12].CFrame = CFrame.new(tipBasePos + backward * halfLen, tipBasePos + backward) * CFrame.Angles(0, math.rad(90), 0)

    -- bottom side (13): offset -X
    parts[13].CFrame = CFrame.new(tipBasePos - torso.CFrame.RightVector * halfLen, tipBasePos + backward)

    -- left side (14): offset -Z, rotated 90°
    parts[14].CFrame = CFrame.new(tipBasePos - backward * halfLen, tipBasePos + backward) * CFrame.Angles(0, math.rad(90), 0)

    -- Crossing parts (15 and 16) near square center, angled
    parts[15].CFrame = CFrame.new(tipBasePos, tipBasePos + backward) * CFrame.Angles(math.rad(45), 0, 0)
    parts[16].CFrame = CFrame.new(tipBasePos, tipBasePos + backward) * CFrame.Angles(math.rad(-45), 0, 0)
end)
