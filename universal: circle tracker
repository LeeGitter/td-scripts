local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Config
local NUM_PARTS = 10
local ORBIT_RADIUS = 3 -- smaller circle radius
local BASE_SIZE = Vector3.new(0.4, 0.5, 0.4)
local MAX_HEIGHT = 5
local SCALE_MULTIPLIER = 0.03
local ORBIT_SPEED = math.rad(90)
local FLOOR_Y_OFFSET = 2
local HORIZONTAL_GAP = 0.05
local CLOSE_RADIUS = 20
local DESPAWN_DISTANCE = 20
local DESPAWN_TIME = 10 -- seconds outside distance before despawn
local HEIGHT_LERP_SPEED = 5 -- higher = faster height changes

local COLOR_START = Color3.fromRGB(255, 0, 255)  -- magenta
local COLOR_END = Color3.fromRGB(0, 255, 100)    -- teal-greenish

local function lerpColor(a, b, t)
    return Color3.new(
        a.R + (b.R - a.R) * t,
        a.G + (b.G - a.G) * t,
        a.B + (b.B - a.B) * t
    )
end

local function lerp(a, b, t)
    return a + (b - a) * t
end

-- Create parts and track their out-of-range timers and current heights
local parts = {}
local outsideTimers = {}
local currentHeights = {}

for i = 1, NUM_PARTS do
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Size = BASE_SIZE
    part.Name = "OrbitingSoundVisualizerPart"
    part.Parent = workspace
    parts[i] = part
    outsideTimers[i] = 0
    currentHeights[i] = BASE_SIZE.Y -- start at base height
end

local angle = 0

RunService.RenderStepped:Connect(function(dt)
    local half = math.floor(NUM_PARTS / 2)

    -- Buckets for close and distributed far sounds (except last part)
    local closeBuckets = {}
    local farBuckets = {}
    for i = 1, half do
        closeBuckets[i] = 0
        farBuckets[i] = 0
    end

    -- Get all playing sounds attached to BaseParts
    local sounds = {}
    for _, sound in ipairs(Workspace:GetDescendants()) do
        if sound:IsA("Sound") and sound.Playing and sound.Parent and sound.Parent:IsA("BasePart") then
            table.insert(sounds, sound)
        end
    end

    -- Separate sounds by distance
    local closeSounds = {}
    local farSounds = {}
    for _, sound in ipairs(sounds) do
        local pos = sound.Parent.Position
        local dist = (pos - hrp.Position).Magnitude
        if dist <= CLOSE_RADIUS then
            table.insert(closeSounds, sound)
        else
            table.insert(farSounds, sound)
        end
    end

    -- Sum loudness for last part (all far sounds combined)
    local farSoundsTotalLoudness = 0
    for _, sound in ipairs(farSounds) do
        farSoundsTotalLoudness = farSoundsTotalLoudness + (sound.PlaybackLoudness or 0)
    end

    -- Distribute close sounds evenly among first half parts
    for i, sound in ipairs(closeSounds) do
        local loudness = sound.PlaybackLoudness or 0
        local index = ((i - 1) % half) + 1
        closeBuckets[index] = closeBuckets[index] + loudness
    end

    -- Distribute far sounds evenly among first (half - 1) parts of the far group
    -- We'll reserve the last part (NUM_PARTS) for total far loudness visualization
    local farGroupParts = half - 1
    for i, sound in ipairs(farSounds) do
        local loudness = sound.PlaybackLoudness or 0
        if farGroupParts > 0 then
            local index = ((i - 1) % farGroupParts) + 1
            farBuckets[index] = farBuckets[index] + loudness
        end
    end

    -- Update parts and check distance for despawn timer
    local partsToRemove = {}

    for i = 1, #parts do
        local targetHeight
        local bucketIndex = ((i - 1) % half) + 1

        if i <= half then
            -- First half parts: close sounds buckets
            targetHeight = math.clamp(BASE_SIZE.Y + closeBuckets[bucketIndex] * SCALE_MULTIPLIER, BASE_SIZE.Y, MAX_HEIGHT)
        elseif i < NUM_PARTS then
            -- Far group except last part: distributed farBuckets
            targetHeight = math.clamp(BASE_SIZE.Y + farBuckets[bucketIndex] * SCALE_MULTIPLIER, BASE_SIZE.Y, MAX_HEIGHT)
        else
            -- Last part (NUM_PARTS): reacts to total far sounds loudness (server-wide outside noises)
            targetHeight = math.clamp(BASE_SIZE.Y + farSoundsTotalLoudness * SCALE_MULTIPLIER, BASE_SIZE.Y, MAX_HEIGHT)
        end

        -- Smoothly lerp current height toward target
        currentHeights[i] = lerp(currentHeights[i], targetHeight, math.clamp(dt * HEIGHT_LERP_SPEED, 0, 1))

        local height = currentHeights[i]

        -- Calculate position with gap offset
        local partAngle = angle + (2 * math.pi * (i - 1) / NUM_PARTS)
        local gapOffset = (height - BASE_SIZE.Y) * HORIZONTAL_GAP
        local x = hrp.Position.X + math.cos(partAngle) * (ORBIT_RADIUS + gapOffset)
        local z = hrp.Position.Z + math.sin(partAngle) * (ORBIT_RADIUS + gapOffset)
        local y = hrp.Position.Y + FLOOR_Y_OFFSET + height / 2

        local part = parts[i]
        part.Position = Vector3.new(x, y, z)
        part.Size = Vector3.new(BASE_SIZE.X, height, BASE_SIZE.Z)
        part.CFrame = CFrame.new(part.Position)

        local t = (height - BASE_SIZE.Y) / (MAX_HEIGHT - BASE_SIZE.Y)
        part.Color = lerpColor(COLOR_START, COLOR_END, t)

        -- Check distance to player for despawn
        local distToPlayer = (part.Position - hrp.Position).Magnitude
        if distToPlayer > DESPAWN_DISTANCE then
            outsideTimers[i] = outsideTimers[i] + dt
            if outsideTimers[i] >= DESPAWN_TIME then
                table.insert(partsToRemove, i)
            end
        else
            outsideTimers[i] = 0
        end
    end

    -- Remove parts safely after loop
    for i = #partsToRemove, 1, -1 do
        local index = partsToRemove[i]
        parts[index]:Destroy()
        table.remove(parts, index)
        table.remove(outsideTimers, index)
        table.remove(currentHeights, index)
    end

    angle = (angle + ORBIT_SPEED * dt) % (2 * math.pi)
end)
