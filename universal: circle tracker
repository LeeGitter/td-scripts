local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local head = character:WaitForChild("Head")
local leftFoot = character:WaitForChild("LeftFoot")
local rightFoot = character:WaitForChild("RightFoot")
local leftHand = character:FindFirstChild("LeftHand")
local rightHand = character:FindFirstChild("RightHand")

-- Configuration
local segmentCount = 10
local crownRadius = 2
local crownHeightOffset = 3
local crownBaseSize = Vector3.new(0.3, 0.5, 0.3)
local maxLoudnessExpected = 1000
local maxCrownHeight = 5

local pillarSpawnInterval = 0.5
local pillarLifetime = 10
local basePillarSize = Vector3.new(0.3, 4, 0.3)
local maxPillarHeight = 8

local trailSpacing = 1
local trailPartSize = Vector3.new(0.15, 0.2, 0.15) -- very thin parts

-- Cleanup old folders
for _, folderName in ipairs({"VisualizerCrown", "LocalPillars", "LocalTrail"}) do
    local folder = workspace:FindFirstChild(folderName)
    if folder then folder:Destroy() end
end

-- Create folders
local crownFolder = Instance.new("Folder", workspace)
crownFolder.Name = "VisualizerCrown"

local pillarFolder = Instance.new("Folder", workspace)
pillarFolder.Name = "LocalPillars"

local trailFolder = Instance.new("Folder", workspace)
trailFolder.Name = "LocalTrail"

-- Crown parts and scale state
local crownParts = {}
local crownPartScales = {}

for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = crownBaseSize
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Transparency = 0
    part.Name = "CrownPart" .. i
    part.Parent = crownFolder
    crownParts[i] = part
    crownPartScales[i] = crownBaseSize.Y
end

-- Spark particle creator (powerful)
local function createSparkParticle(parent)
    local particle = Instance.new("ParticleEmitter")
    particle.Texture = "rbxassetid://243660364"
    particle.Rate = 80
    particle.Lifetime = NumberRange.new(0.7, 1.2)
    particle.Speed = NumberRange.new(0.5, 1.5)
    particle.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.8),
        NumberSequenceKeypoint.new(1, 0)
    }
    particle.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromHSV(0, 0.7, 1)),
        ColorSequenceKeypoint.new(1, Color3.fromHSV(0.7, 0.8, 1))
    }
    particle.LightEmission = 1
    particle.EmissionDirection = Enum.NormalId.Top
    particle.RotSpeed = NumberRange.new(10, 20)
    particle.Parent = parent
    return particle
end

-- Attach spark particles to hands and feet
local sparkEmitters = {}
for _, limb in pairs({leftHand, rightHand, leftFoot, rightFoot}) do
    if limb then
        sparkEmitters[limb.Name] = createSparkParticle(limb)
    end
end

-- Trail data
local trailParts = {}
local lastTrailPosLeft = nil
local lastTrailPosRight = nil

-- Pillars and scales
local pillars = {}
local pillarScales = {}

-- Utility: get all playing sounds NOT parented to a BasePart
local function getUnparentedSounds()
    local sounds = {}

    local function addSoundsFrom(root)
        for _, obj in pairs(root:GetDescendants()) do
            if obj:IsA("Sound") and obj.IsPlaying and not obj.Parent:IsA("BasePart") then
                table.insert(sounds, obj)
            end
        end
    end

    addSoundsFrom(workspace)
    if player:FindFirstChild("PlayerGui") then addSoundsFrom(player.PlayerGui) end
    if character then addSoundsFrom(character) end
    addSoundsFrom(SoundService)

    return sounds
end

-- Create trail part on ground at position
local function createTrailPart(position)
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = trailPartSize
    part.Transparency = 1
    part.Position = Vector3.new(position.X, trailPartSize.Y / 2, position.Z)
    part.Parent = trailFolder
    createSparkParticle(part)
    return part
end

-- Create pillar at ground level
local function createPillar(position)
    local pillar = Instance.new("Part")
    pillar.Anchored = true
    pillar.CanCollide = false
    pillar.Size = basePillarSize
    pillar.Material = Enum.Material.Neon
    pillar.CastShadow = false
    pillar.Transparency = 0
    pillar.Position = position + Vector3.new(0, basePillarSize.Y / 2, 0)
    pillar.Parent = pillarFolder
    pillar:SetAttribute("SpawnTime", tick())
    return pillar
end

local lastPillarSpawnTime = 0

-- For crown wobble
local prevTiltX, prevTiltZ = 0, 0
local wobbleTime = 0
local wobbleActive = false
local lastPitch, lastRoll = 0, 0

RunService.Heartbeat:Connect(function(dt)
    if not character or not character.Parent then
        character = player.Character or player.CharacterAdded:Wait()
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        head = character:WaitForChild("Head")
        leftFoot = character:WaitForChild("LeftFoot")
        rightFoot = character:WaitForChild("RightFoot")
        leftHand = character:FindFirstChild("LeftHand")
        rightHand = character:FindFirstChild("RightHand")

        -- Reattach spark emitters
        for _, emitter in pairs(sparkEmitters) do
            if emitter then
                emitter:Destroy()
            end
        end
        sparkEmitters = {}
        for _, limb in pairs({leftHand, rightHand, leftFoot, rightFoot}) do
            if limb then
                sparkEmitters[limb.Name] = createSparkParticle(limb)
            end
        end

        -- Clear trail and pillars
        for _, part in pairs(trailParts) do
            if part and part.Parent then part:Destroy() end
        end
        trailParts = {}

        for _, pillar in pairs(pillars) do
            if pillar and pillar.Parent then pillar:Destroy() end
        end
        pillars = {}
        pillarScales = {}
        lastTrailPosLeft = nil
        lastTrailPosRight = nil
    end

    -- Trail creation under feet while walking
    local function addTrailIfFarEnough(lastPos, currentPos)
        if not lastPos or (lastPos - currentPos).Magnitude >= trailSpacing then
            local newPart = createTrailPart(currentPos)
            table.insert(trailParts, newPart)
            return currentPos
        end
        return lastPos
    end

    if leftFoot and rightFoot then
        lastTrailPosLeft = addTrailIfFarEnough(lastTrailPosLeft, leftFoot.Position)
        lastTrailPosRight = addTrailIfFarEnough(lastTrailPosRight, rightFoot.Position)
    end

    -- Spawn pillars every 0.5s above trail parts, two pillars per trail part offset left/right
    if tick() - lastPillarSpawnTime >= pillarSpawnInterval then
        lastPillarSpawnTime = tick()

        for _, trailPart in pairs(trailParts) do
            local basePos = trailPart.Position
            local offsetLeft = Vector3.new(-0.15, 0, 0)
            local offsetRight = Vector3.new(0.15, 0, 0)

            local pillar1 = createPillar(Vector3.new(basePos.X, 0, basePos.Z) + offsetLeft)
            local pillar2 = createPillar(Vector3.new(basePos.X, 0, basePos.Z) + offsetRight)

            table.insert(pillars, pillar1)
            table.insert(pillarScales, basePillarSize.Y)
            table.insert(pillars, pillar2)
            table.insert(pillarScales, basePillarSize.Y)
        end
    end

    -- Remove old pillars (older than pillarLifetime)
    for i = #pillars, 1, -1 do
        local pillar = pillars[i]
        if pillar and pillar.Parent then
            local age = tick() - pillar:GetAttribute("SpawnTime")
            if age > pillarLifetime then
                pillar:Destroy()
                table.remove(pillars, i)
                table.remove(pillarScales, i)
            end
        else
            table.remove(pillars, i)
            table.remove(pillarScales, i)
        end
    end

    -- Get all unparented sounds
    local sounds = getUnparentedSounds()
    local soundCount = #sounds
    if soundCount == 0 then soundCount = 1 end

    -- Crown wobble and scaling
    local wobbleDuration = 0.5
    local tiltSmoothing = 0.1
    local tiltIntensity = 0.1
    local wobbleAmplitudePos = 0.2
    local wobbleAmplitudeRot = 0.09
    local wobbleTriggerThreshold = 0.05

    local headCFrame = head.CFrame
    local pitch, roll = headCFrame:ToEulerAnglesXYZ()

    if math.abs(pitch - lastPitch) > wobbleTriggerThreshold or math.abs(roll - lastRoll) > wobbleTriggerThreshold then
        wobbleActive = true
        wobbleTime = 0
    end
    lastPitch = pitch
    lastRoll = roll

    local targetTiltX = -pitch * tiltIntensity
    local targetTiltZ = -roll * tiltIntensity
    prevTiltX = prevTiltX + (targetTiltX - prevTiltX) * tiltSmoothing
    prevTiltZ = prevTiltZ + (targetTiltZ - prevTiltZ) * tiltSmoothing

    if wobbleActive then
        wobbleTime = wobbleTime + dt
        if wobbleTime > wobbleDuration then
            wobbleActive = false
            wobbleTime = wobbleDuration
        end
    end

    local wobbleProgress = wobbleTime / wobbleDuration
    local wobblePosOffset = 0
    local wobbleRotOffset = 0
    if wobbleActive then
        local decay = 1 - wobbleProgress
        wobblePosOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudePos * decay
        wobbleRotOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudeRot * decay
    end

    local tiltRotation = CFrame.Angles(prevTiltX, 0, prevTiltZ + wobbleRotOffset)
    local baseCFrame = headCFrame * CFrame.new(wobblePosOffset, crownHeightOffset, 0) * tiltRotation

    -- Update crown parts
    for i, part in ipairs(crownParts) do
        local angle = (2 * math.pi / segmentCount) * i
        local localOffset = Vector3.new(math.cos(angle) * crownRadius, 0, math.sin(angle) * crownRadius)
        local worldPos = baseCFrame:PointToWorldSpace(localOffset)

        local sound = sounds[((i - 1) % soundCount) + 1]
        local loudness = 0
        if sound then
            loudness = sound.PlaybackLoudness or 0
        end
        local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
        local targetHeight = 0.5 + normalized * (maxCrownHeight - 0.5)

        crownPartScales[i] = crownPartScales[i] + (targetHeight - crownPartScales[i]) * 0.15
        part.Size = Vector3.new(crownBaseSize.X, crownPartScales[i], crownBaseSize.Z)

        part.Position = worldPos + Vector3.new(0, crownPartScales[i] / 2, 0)

        local yawAngle = math.deg(math.atan2(localOffset.Z, localOffset.X))
        part.Orientation = Vector3.new(0, yawAngle, 0)
    end

    -- Update pillar scaling
    for i, pillar in ipairs(pillars) do
        if pillar and pillar.Parent then
            local sound = sounds[((i - 1) % soundCount) + 1]
            local loudness = 0
            if sound then
                loudness = sound.PlaybackLoudness or 0
            end
            local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
            local targetHeight = basePillarSize.Y + normalized * maxPillarHeight
            pillarScales[i] = pillarScales[i] + (targetHeight - pillarScales[i]) * 0.25

            pillar.Size = Vector3.new(basePillarSize.X, pillarScales[i], basePillarSize.Z)
            pillar.Position = Vector3.new(pillar.Position.X, pillar.Size.Y / 2, pillar.Position.Z)
        end
    end
end)
