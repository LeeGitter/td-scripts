local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local head = character:WaitForChild("Head")

-- ======= Crown setup =======
local segmentCount = 10
local radius = 2
local heightOffset = 3
local basePartSize = Vector3.new(0.3, 0.5, 0.3)
local soundDetectionRadius = 60
local maxLoudnessExpected = 1000
local maxPartHeight = 5

-- Clear existing crown folder if any
local crownFolder = workspace:FindFirstChild("VisualizerCrown")
if crownFolder then
    crownFolder:Destroy()
end
crownFolder = Instance.new("Folder")
crownFolder.Name = "VisualizerCrown"
crownFolder.Parent = workspace

local crownParts = {}
local crownPartScales = {}

for i = 1, segmentCount do
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = basePartSize
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromHSV(i / segmentCount, 1, 1)
    part.Transparency = 0
    part.Name = "CrownPart"..i
    part.Parent = crownFolder
    crownParts[i] = part
    crownPartScales[i] = basePartSize.Y
end

-- ======= Pillars setup =======
local pillarsFolder = workspace:FindFirstChild("FootPillars")
if pillarsFolder then pillarsFolder:Destroy() end
pillarsFolder = Instance.new("Folder", workspace)
pillarsFolder.Name = "FootPillars"

local pillarBaseSize = Vector3.new(0.2, 2, 0.2)
local pillarSpawnInterval = 0.5
local pillarLifetime = 10
local lastPillarSpawn = 0
local pillars = {}

-- ======= Utility: Get all playing sounds =======
local function getAllPlayingSounds()
    local sounds = {}

    local function addSoundsFrom(parent)
        for _, obj in pairs(parent:GetDescendants()) do
            if obj:IsA("Sound") and obj.IsPlaying then
                table.insert(sounds, obj)
            end
        end
    end

    addSoundsFrom(workspace)
    addSoundsFrom(player:WaitForChild("PlayerGui"))
    addSoundsFrom(character)

    return sounds
end

local function getTotalLoudness()
    local total = 0
    local sounds = getAllPlayingSounds()
    for _, sound in pairs(sounds) do
        total = total + (sound.PlaybackLoudness or 0)
    end
    return total
end

-- ======= Pillar creation =======
local function createPillar(position)
    local pillar = Instance.new("Part")
    pillar.Anchored = true
    pillar.CanCollide = false
    pillar.Material = Enum.Material.Neon
    pillar.Color = Color3.fromHSV(math.random(), 0.6, 1) -- pastel rainbow
    pillar.Size = pillarBaseSize
    pillar.CFrame = CFrame.new(position.X, position.Y + pillarBaseSize.Y / 2, position.Z)
    pillar.Parent = pillarsFolder

    return {
        part = pillar,
        spawnTime = tick()
    }
end

-- ======= Main loop =======
local prevTiltX, prevTiltZ = 0, 0
local tiltSmoothing = 0.1
local tiltIntensity = 0.1

local wobbleDuration = 0.5
local wobbleTime = 0
local wobbleAmplitudePos = 0.2
local wobbleAmplitudeRot = 0.09
local wobbleActive = false

local lastPitch, lastRoll = 0, 0
local wobbleTriggerThreshold = 0.05

RunService.Heartbeat:Connect(function(dt)
    -- Refresh character references after respawn
    if not character or not character.Parent then
        character = player.Character or player.CharacterAdded:Wait()
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        head = character:WaitForChild("Head")
    end

    -- Crown Logic
    local headCFrame = head.CFrame
    local pitch, roll = headCFrame:ToEulerAnglesXYZ()

    if math.abs(pitch - lastPitch) > wobbleTriggerThreshold or math.abs(roll - lastRoll) > wobbleTriggerThreshold then
        wobbleActive = true
        wobbleTime = 0
    end
    lastPitch = pitch
    lastRoll = roll

    local targetTiltX = -pitch * tiltIntensity
    local targetTiltZ = -roll * tiltIntensity
    prevTiltX = prevTiltX + (targetTiltX - prevTiltX) * tiltSmoothing
    prevTiltZ = prevTiltZ + (targetTiltZ - prevTiltZ) * tiltSmoothing

    if wobbleActive then
        wobbleTime = wobbleTime + dt
        if wobbleTime > wobbleDuration then
            wobbleActive = false
            wobbleTime = wobbleDuration
        end
    end

    local wobbleProgress = wobbleTime / wobbleDuration
    local wobblePosOffset = 0
    local wobbleRotOffset = 0
    if wobbleActive then
        local decay = 1 - wobbleProgress
        wobblePosOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudePos * decay
        wobbleRotOffset = math.sin(wobbleTime * math.pi * 4) * wobbleAmplitudeRot * decay
    end

    local tiltRotation = CFrame.Angles(prevTiltX, 0, prevTiltZ + wobbleRotOffset)
    local baseCFrame = headCFrame * CFrame.new(wobblePosOffset, heightOffset, 0) * tiltRotation

    local sounds = getAllPlayingSounds()
    local totalLoudness = 0
    for _, sound in pairs(sounds) do
        totalLoudness = totalLoudness + (sound.PlaybackLoudness or 0)
    end

    local highlightTriggeredThisFrame = false

    for i, part in ipairs(crownParts) do
        local angle = (2 * math.pi / segmentCount) * i
        local localOffset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
        local worldPos = baseCFrame:PointToWorldSpace(localOffset)

        local soundIndex = #sounds > 0 and ((i - 1) % #sounds) + 1 or nil
        local sound = soundIndex and sounds[soundIndex] or nil

        local loudness = 0
        if sound then
            loudness = sound.PlaybackLoudness or 0
        end

        local normalized = math.clamp(loudness / maxLoudnessExpected, 0, 1)
        local targetHeight = 0.5 + normalized * (maxPartHeight - 0.5)

        crownPartScales[i] = crownPartScales[i] + (targetHeight - crownPartScales[i]) * 0.15
        part.Size = Vector3.new(basePartSize.X, crownPartScales[i], basePartSize.Z)

        part.Position = worldPos + Vector3.new(0, crownPartScales[i] / 2, 0)

        local yawAngle = math.deg(math.atan2(localOffset.Z, localOffset.X))
        part.Orientation = Vector3.new(0, yawAngle, 0)

        if not highlightTriggeredThisFrame and crownPartScales[i] >= maxPartHeight - 0.1 then
            highlightTriggeredThisFrame = true
        end
    end

    -- Pillars Logic
    local speed = humanoidRootPart.Velocity.Magnitude
    if speed > 1 then
        lastPillarSpawn = lastPillarSpawn + dt
        if lastPillarSpawn >= pillarSpawnInterval then
            lastPillarSpawn = 0

            -- Two pillars per foot
            local leftFootOffset1 = Vector3.new(-0.5, -3, 0.5)
            local leftFootOffset2 = Vector3.new(-0.7, -3, 0)
            local rightFootOffset1 = Vector3.new(0.5, -3, 0.5)
            local rightFootOffset2 = Vector3.new(0.7, -3, 0)

            table.insert(pillars, createPillar(humanoidRootPart.Position + leftFootOffset1))
            table.insert(pillars, createPillar(humanoidRootPart.Position + leftFootOffset2))
            table.insert(pillars, createPillar(humanoidRootPart.Position + rightFootOffset1))
            table.insert(pillars, createPillar(humanoidRootPart.Position + rightFootOffset2))
        end
    end

    local normalizedLoudness = math.clamp(totalLoudness / 1000, 0, 1)
    local targetHeight = 2 + normalizedLoudness * 8 -- pillars height between 2 and 10

    for i = #pillars, 1, -1 do
        local data = pillars[i]
        local part = data.part
        local age = tick() - data.spawnTime

        if age >= pillarLifetime or not part.Parent then
            part:Destroy()
            table.remove(pillars, i)
        else
            local alpha = 1 - (age / pillarLifetime)
            part.Transparency = 1 - (alpha * 0.8) -- fade out

            -- Smooth height lerp
            local currentSizeY = part.Size.Y
            local newSizeY = currentSizeY + (targetHeight - currentSizeY) * dt * 10
            part.Size = Vector3.new(pillarBaseSize.X, newSizeY, pillarBaseSize.Z)

            -- Keep base at foot level
            local pos = part.Position
            part.CFrame = CFrame.new(pos.X, humanoidRootPart.Position.Y - 3 + newSizeY / 2, pos.Z)
        end
    end
end)
