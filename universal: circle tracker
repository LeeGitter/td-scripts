local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")

-- Tail Settings
local NUM_SEGMENTS = 16
local BASE_SIZE = Vector3.new(0.5, 0.5, 0.7)
local LENGTH_PER_SEGMENT = 0.7

local BASE_OFFSET = Vector3.new(0, -1.5, 1.5) -- Base offset low on waist/back
local MAX_PITCH_ANGLE = math.rad(30)          -- Max upward pitch angle at tail tip

local BUILD_DELAY = 0.1

local segments = {}
local attachments = {}
local ballSockets = {}
local alignOrientations = {}

local tailRootAttachment = nil
local cube = nil
local cubeHue = 0

-- Cleanup old tail
if character:FindFirstChild("TailRoot") then
	character.TailRoot:Destroy()
end

-- Create root attachment on torso at base offset
tailRootAttachment = Instance.new("Attachment")
tailRootAttachment.Name = "TailRoot"
tailRootAttachment.Position = BASE_OFFSET
tailRootAttachment.Parent = torso

-- Create tail segment parts WITHOUT physics enabled initially
local function createSegment(index)
	local part = Instance.new("Part")
	part.Name = "TailSegment_" .. index
	part.Size = BASE_SIZE + Vector3.new(index * 0.05, index * 0.05, 0)
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromHSV((index / NUM_SEGMENTS) % 1, 1, 1)
	part.Anchored = true  -- initially anchored
	part.CanCollide = false
	part.Massless = true
	part.CastShadow = false
	part.Parent = workspace

	local att0 = Instance.new("Attachment", part)
	att0.Name = "Attachment0"
	att0.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local att1 = Instance.new("Attachment", part)
	att1.Name = "Attachment1"
	att1.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	return part, att0, att1
end

-- Build tail anchored, with upward curve applied by rotating each segment slightly more pitch upward
coroutine.wrap(function()
	local lastAttachment = tailRootAttachment

	for i = 1, NUM_SEGMENTS do
		local part, att0, att1 = createSegment(i)
		segments[i] = part
		attachments[i] = {att0, att1}

		-- Normalized position along tail [0..1]
		local t = (i - 1) / (NUM_SEGMENTS - 1)

		-- Calculate pitch angle increasing from 0 to MAX_PITCH_ANGLE along tail
		local pitchAngle = MAX_PITCH_ANGLE * t

		-- Base position behind torso
		local basePos = Vector3.new(0, BASE_OFFSET.Y, -BASE_OFFSET.Z - LENGTH_PER_SEGMENT * (i - 1))

		-- Compose CFrame: torso CFrame * position * pitch rotation upward
		local cframe = torso.CFrame * CFrame.new(basePos) * CFrame.Angles(pitchAngle, 0, 0)

		part.CFrame = cframe
		part.Anchored = true

		lastAttachment = att1
		wait(BUILD_DELAY)
	end

	-- Enable physics and constraints after building
	for i = 1, NUM_SEGMENTS do
		local part = segments[i]
		part.Anchored = false

		local ballSocket = Instance.new("BallSocketConstraint")
		ballSocket.Attachment0 = (i == 1) and tailRootAttachment or attachments[i - 1][2]
		ballSocket.Attachment1 = attachments[i][1]
		ballSocket.LimitsEnabled = true
		ballSocket.TwistLimitsEnabled = true
		ballSocket.UpperAngle = 25
		ballSocket.TwistLowerAngle = -15
		ballSocket.TwistUpperAngle = 15
		ballSocket.Parent = part
		ballSockets[i] = ballSocket

		local alignOri = Instance.new("AlignOrientation")
		alignOri.Attachment0 = attachments[i][1]
		alignOri.Attachment1 = (i == 1) and tailRootAttachment or attachments[i - 1][2]
		alignOri.Mode = Enum.OrientationAlignmentMode.OneAttachment
		alignOri.ReactionTorqueEnabled = true
		alignOri.Responsiveness = 10
		alignOri.MaxTorque = 10000
		alignOri.Parent = part
		alignOrientations[i] = alignOri
	end

	-- Create spinning pastel cube at tip
	cube = Instance.new("Part")
	cube.Shape = Enum.PartType.Block
	cube.Size = Vector3.new(1.5, 1.5, 1.5)
	cube.Material = Enum.Material.Neon
	cube.CanCollide = false
	cube.Anchored = false
	cube.Massless = true
	cube.CastShadow = false
	cube.Parent = workspace

	local attachTail = Instance.new("Attachment", segments[#segments])
	attachTail.Position = Vector3.new(0, 0, -LENGTH_PER_SEGMENT / 2)

	local attachCube = Instance.new("Attachment", cube)
	attachCube.Position = Vector3.new(0, 0, LENGTH_PER_SEGMENT / 2)

	local hinge = Instance.new("HingeConstraint")
	hinge.Attachment0 = attachTail
	hinge.Attachment1 = attachCube
	hinge.Parent = cube
	hinge.MotorMaxTorque = math.huge
	hinge.AngularVelocity = 5
end)()

local lastPos = torso.Position
RunService.RenderStepped:Connect(function()
	if #segments == 0 then return end

	local moveVec = torso.Velocity

	for i, part in ipairs(segments) do
		local phase = tick() * 2 + i
		local sway = math.sin(phase) * (moveVec.Magnitude * 5)
		local offset = Vector3.new(sway * 0.05, 0, 0)
		part.AssemblyLinearVelocity = offset
	end

	if cube then
		cubeHue = (cubeHue + 0.005) % 1
		cube.Color = Color3.fromHSV(cubeHue, 0.4, 1)
		cube.RotVelocity = Vector3.new(2, 4, 1)
	end
end)
