local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local leftLeg = character:WaitForChild("Left Leg")
local rightLeg = character:WaitForChild("Right Leg")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Pillar properties
local pillarSize = Vector3.new(0.3, 5, 0.3) -- tall pillars
local afterimageLifetime = 4
local afterimageFadeTime = 4
local afterimageSpawnInterval = 0.15

-- Particle aura properties
local auraParticleCount = 30
local auraRadius = 0.5

-- Audio detection
local soundDetectionRadius = 60
local maxLoudnessExpected = 1000

-- Folder to hold pillars
local pillarFolder = Workspace:FindFirstChild("LocalPillars")
if pillarFolder then
    pillarFolder:Destroy()
end
pillarFolder = Instance.new("Folder")
pillarFolder.Name = "LocalPillars"
pillarFolder.Parent = Workspace

-- Create particle emitters for feet aura
local function createAuraEmitter(parentPart)
    local particleEmitter = Instance.new("ParticleEmitter")
    particleEmitter.Color = ColorSequence.new(Color3.fromHSV(0, 0.6, 1)) -- start with pastel red
    particleEmitter.LightEmission = 0.7
    particleEmitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.15), NumberSequenceKeypoint.new(1, 0)})
    particleEmitter.Rate = 60
    particleEmitter.Speed = NumberRange.new(0.5, 1)
    particleEmitter.Lifetime = NumberRange.new(1, 1.5)
    particleEmitter.Rotation = NumberRange.new(0, 360)
    particleEmitter.RotSpeed = NumberRange.new(-90, 90)
    particleEmitter.EmissionDirection = Enum.NormalId.Top
    particleEmitter.LockedToPart = true
    particleEmitter.Parent = parentPart
    return particleEmitter
end

local leftAura = createAuraEmitter(leftLeg)
local rightAura = createAuraEmitter(rightLeg)

local lastPillarSpawnTime = 0
local hue = 0

-- Helper: Get nearby playing sounds within radius
local function getNearbySounds(position)
    local sounds = {}
    for _, sound in pairs(Workspace:GetDescendants()) do
        if sound:IsA("Sound") and sound.IsPlaying and (sound.Parent and sound.Parent:IsA("BasePart")) then
            local pos = sound.Parent.Position
            if (pos - position).Magnitude <= soundDetectionRadius then
                table.insert(sounds, sound)
            end
        end
    end
    return sounds
end

-- Create a pillar at a position
local function createPillar(position)
    local pillar = Instance.new("Part")
    pillar.Anchored = true
    pillar.CanCollide = false
    pillar.Size = pillarSize
    pillar.Material = Enum.Material.Neon
    pillar.Color = Color3.fromHSV(hue, 0.6, 1)
    pillar.CFrame = CFrame.new(position + Vector3.new(0, pillarSize.Y/2, 0))
    pillar.Transparency = 0
    pillar.CastShadow = false
    pillar.Parent = pillarFolder
    return pillar
end

-- Afterimage pulse and fade coroutine
local function animatePillar(pillar)
    spawn(function()
        local startTime = tick()
        while true do
            local dt = RunService.Heartbeat:Wait()
            local elapsed = tick() - startTime
            if elapsed > afterimageLifetime then
                pillar:Destroy()
                break
            end

            -- Find loudness of nearby sounds to pillar
            local sounds = getNearbySounds(pillar.Position)
            local maxLoudness = 0
            for _, sound in pairs(sounds) do
                local loudness = sound.PlaybackLoudness or 0
                if loudness > maxLoudness then maxLoudness = loudness end
            end

            local loudnessNorm = math.clamp(maxLoudness / maxLoudnessExpected, 0, 1)
            local pulseHeight = 1 + loudnessNorm * 3 -- scale height from 1x to 4x

            -- Adjust pillar size Y (height) smoothly
            local currentSize = pillar.Size
            local targetY = pillarSize.Y * pulseHeight
            local newY = currentSize.Y + (targetY - currentSize.Y) * 0.2
            pillar.Size = Vector3.new(currentSize.X, newY, currentSize.Z)

            -- Adjust CFrame so bottom stays on ground
            local basePos = pillar.Position - Vector3.new(0, currentSize.Y / 2, 0)
            pillar.CFrame = CFrame.new(basePos + Vector3.new(0, newY / 2, 0))

            -- Fade out transparency over time
            local fadeAlpha = math.clamp(elapsed / afterimageFadeTime, 0, 1)
            pillar.Transparency = fadeAlpha

            -- Cycle color hue
            hue = (hue + dt * 0.5) % 1
            pillar.Color = Color3.fromHSV(hue, 0.6, 1)
        end
    end)
end

RunService.Heartbeat:Connect(function(dt)
    if not character or not character.Parent then
        character = player.Character or player.CharacterAdded:Wait()
        leftLeg = character:WaitForChild("Left Leg")
        rightLeg = character:WaitForChild("Right Leg")
        rootPart = character:WaitForChild("HumanoidRootPart")
        leftAura = createAuraEmitter(leftLeg)
        rightAura = createAuraEmitter(rightLeg)
    end

    hue = (hue + dt * 0.5) % 1
    local pastelColor = Color3.fromHSV(hue, 0.6, 1)

    -- Update aura colors on feet
    if leftAura and leftAura.Parent then
        leftAura.Color = ColorSequence.new(pastelColor)
    end
    if rightAura and rightAura.Parent then
        rightAura.Color = ColorSequence.new(pastelColor)
    end

    local speed = rootPart.Velocity.Magnitude
    if speed > 1 and tick() - lastPillarSpawnTime > afterimageSpawnInterval then
        -- Spawn pillars near feet positions, offset a little behind root part to simulate trail
        if leftLeg then
            local pos = leftLeg.Position - rootPart.CFrame.LookVector * 0.5
            local pillar = createPillar(pos)
            animatePillar(pillar)
        end
        if rightLeg then
            local pos = rightLeg.Position - rootPart.CFrame.LookVector * 0.5
            local pillar = createPillar(pos)
            animatePillar(pillar)
        end
        lastPillarSpawnTime = tick()
    end
end)
