local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Wall jump animation
local wallJumpAnim = Instance.new("Animation")
wallJumpAnim.AnimationId = "rbxassetid://80512938371187"
local wallJumpTrack = humanoid:LoadAnimation(wallJumpAnim)

local WALL_JUMP_DISTANCE = 3 -- studs to detect wall
local WALL_JUMP_FORCE = 50 -- force away from wall
local WALL_JUMP_UPWARD_VELOCITY = 50
local WALL_JUMP_COOLDOWN = 0.2 -- to prevent spamming

local WALK_SPEED_NORMAL = 28
local WALK_SPEED_BOOST = 38
local BOOST_DURATION = 0.8

local DESCEND_SLOW_DURATION = 0.8
local DESCEND_SLOW_FACTOR = 0.4

local lastWallJumpTime = 0
local descendSlowEndTime = 0

local function findWallDirection()
    local directions = {
        hrp.CFrame.LookVector,  -- front
        -hrp.CFrame.LookVector, -- back
        hrp.CFrame.RightVector, -- right
        -hrp.CFrame.RightVector -- left
    }
    for _, dir in pairs(directions) do
        local origin = hrp.Position
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

        local raycastResult = workspace:Raycast(origin, dir * WALL_JUMP_DISTANCE, raycastParams)
        if raycastResult and raycastResult.Instance and raycastResult.Instance.CanCollide then
            return dir
        end
    end
    return nil
end

local function setWalkSpeed(speed)
    if humanoid and humanoid.Parent then
        humanoid.WalkSpeed = speed
    end
end

local function playWallJumpAnimation()
    if wallJumpTrack.IsPlaying then
        wallJumpTrack:Stop(0)
    end
    wallJumpTrack:Play(0.1, 1, 1)
    delay(0.51, function()
        if wallJumpTrack.IsPlaying then
            wallJumpTrack:Stop(0)
        end
    end)
end

local function doWallJump()
    local now = tick()
    if now - lastWallJumpTime < WALL_JUMP_COOLDOWN then
        return
    end

    local state = humanoid:GetState()
    if not (state == Enum.HumanoidStateType.Freefall or state == Enum.HumanoidStateType.Jumping) then
        return
    end

    local wallDir = findWallDirection()
    if not wallDir then
        return
    end

    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

    local velocity = -wallDir.Unit * WALL_JUMP_FORCE
    velocity = Vector3.new(velocity.X, WALL_JUMP_UPWARD_VELOCITY, velocity.Z)
    hrp.Velocity = velocity

    playWallJumpAnimation()

    -- Speed boost and slow descend
    setWalkSpeed(WALK_SPEED_BOOST)
    delay(BOOST_DURATION, function()
        setWalkSpeed(WALK_SPEED_NORMAL)
    end)

    descendSlowEndTime = now + DESCEND_SLOW_DURATION

    lastWallJumpTime = now
end

-- Slow descent logic
RunService.Heartbeat:Connect(function()
    if tick() < descendSlowEndTime then
        local vel = hrp.Velocity
        if vel.Y < 0 then
            hrp.Velocity = Vector3.new(vel.X, vel.Y * DESCEND_SLOW_FACTOR, vel.Z)
        end
    end
end)

UserInputService.JumpRequest:Connect(function()
    doWallJump()
end)

player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")

    wallJumpAnim = Instance.new("Animation")
    wallJumpAnim.AnimationId = "rbxassetid://80512938371187"
    wallJumpTrack = humanoid:LoadAnimation(wallJumpAnim)
end)
