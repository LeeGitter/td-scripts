local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

local WALL_JUMP_DISTANCE = 3
local WALL_JUMP_FORCE = 50
local WALL_JUMP_UPWARD_VELOCITY = 50
local WALL_JUMP_COOLDOWN = 0.2

local WALK_SPEED_NORMAL = 28
local WALK_SPEED_BOOST = 38
local BOOST_DURATION = 0.8

local DESCEND_SLOW_DURATION = 0.8
local DESCEND_SLOW_FACTOR = 0.4

local character
local humanoid
local hrp

local wallJumpAnim
local wallJumpTrack

local lastWallJumpTime = 0
local descendSlowEndTime = 0

-- Connections to manage and disconnect on respawn
local jumpRequestConn
local heartbeatConn

local function setWalkSpeed(speed)
    if humanoid and humanoid.Parent then
        humanoid.WalkSpeed = speed
    end
end

local function findWallDirection()
    local directions = {
        hrp.CFrame.LookVector,
        -hrp.CFrame.LookVector,
        hrp.CFrame.RightVector,
        -hrp.CFrame.RightVector
    }
    for _, dir in pairs(directions) do
        local origin = hrp.Position
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

        local raycastResult = workspace:Raycast(origin, dir * WALL_JUMP_DISTANCE, raycastParams)
        if raycastResult and raycastResult.Instance and raycastResult.Instance.CanCollide then
            return dir
        end
    end
    return nil
end

local function playWallJumpAnimation()
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        track:Stop(0)
    end

    wallJumpTrack:Play(0.1, 1, 1)

    delay(0.51, function()
        if wallJumpTrack.IsPlaying then
            wallJumpTrack:Stop(0)
        end
    end)
end

local function doWallJump()
    local now = tick()
    if now - lastWallJumpTime < WALL_JUMP_COOLDOWN then
        return
    end

    local state = humanoid:GetState()
    if not (state == Enum.HumanoidStateType.Freefall or state == Enum.HumanoidStateType.Jumping) then
        return
    end

    local wallDir = findWallDirection()
    if not wallDir then
        return
    end

    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

    local velocity = -wallDir.Unit * WALL_JUMP_FORCE
    velocity = Vector3.new(velocity.X, WALL_JUMP_UPWARD_VELOCITY, velocity.Z)
    hrp.Velocity = velocity

    playWallJumpAnimation()

    setWalkSpeed(WALK_SPEED_BOOST)
    delay(BOOST_DURATION, function()
        setWalkSpeed(WALK_SPEED_NORMAL)
    end)

    descendSlowEndTime = now + DESCEND_SLOW_DURATION

    lastWallJumpTime = now
end

local function onHeartbeat()
    if tick() < descendSlowEndTime then
        local vel = hrp.Velocity
        if vel.Y < 0 then
            hrp.Velocity = Vector3.new(vel.X, vel.Y * DESCEND_SLOW_FACTOR, vel.Z)
        end
    end
end

local function onCharacterAdded(char)
    -- Cleanup old connections if any
    if jumpRequestConn then
        jumpRequestConn:Disconnect()
        jumpRequestConn = nil
    end
    if heartbeatConn then
        heartbeatConn:Disconnect()
        heartbeatConn = nil
    end

    character = char
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")

    wallJumpAnim = Instance.new("Animation")
    wallJumpAnim.AnimationId = "rbxassetid://80512938371187"
    wallJumpAnim.Priority = Enum.AnimationPriority.Action
    wallJumpTrack = humanoid:LoadAnimation(wallJumpAnim)

    lastWallJumpTime = 0
    descendSlowEndTime = 0

    setWalkSpeed(WALK_SPEED_NORMAL)

    jumpRequestConn = UserInputService.JumpRequest:Connect(doWallJump)
    heartbeatConn = RunService.Heartbeat:Connect(onHeartbeat)
end

player.CharacterAdded:Connect(onCharacterAdded)

-- Initialize for current character if loaded
if player.Character then
    onCharacterAdded(player.Character)
end
