local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

-- Disable Roblox automatic rotation to control facing manually
humanoid.AutoRotate = false

-- Track keys pressed
local keysPressed = {
    W = false,
    A = false,
    S = false,
    D = false,
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = true end
    if key == Enum.KeyCode.A then keysPressed.A = true end
    if key == Enum.KeyCode.S then keysPressed.S = true end
    if key == Enum.KeyCode.D then keysPressed.D = true end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = false end
    if key == Enum.KeyCode.A then keysPressed.A = false end
    if key == Enum.KeyCode.S then keysPressed.S = false end
    if key == Enum.KeyCode.D then keysPressed.D = false end
end)

-- Helper: Snap angle (radians) to nearest 45 degrees
local function snapAngle(angle)
    local degrees = math.deg(angle)
    local snappedDegrees = math.floor((degrees + 22.5) / 45) * 45
    return math.rad(snappedDegrees)
end

-- WS flicker state
local wsToggle = false
local wsTimer = 0
local wsInterval = 0.05 -- seconds

RunService.RenderStepped:Connect(function(dt)
    -- Snap camera yaw rotation
    local camCFrame = camera.CFrame
    local camPos = camCFrame.Position

    -- Extract current yaw from camera look vector (XZ plane)
    local lookVec = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z)
    if lookVec.Magnitude < 0.001 then return end -- avoid errors on edge cases
    lookVec = lookVec.Unit

    local camYaw = math.atan2(lookVec.Z, lookVec.X)
    local snappedYaw = snapAngle(camYaw)

    -- Rebuild snapped camera CFrame keeping pitch and roll intact
    local camPitch = math.asin(camCFrame.LookVector.Y) -- approx pitch

    -- Construct new look vector from snapped yaw and pitch
    local horizontalLook = Vector3.new(math.cos(snappedYaw), 0, math.sin(snappedYaw))
    local rightVec = Vector3.new(-horizontalLook.Z, 0, horizontalLook.X)
    local newLook = (CFrame.fromAxisAngle(rightVec, camPitch) * CFrame.lookAt(Vector3.new(), horizontalLook)).LookVector

    local newCamCFrame = CFrame.new(camPos, camPos + newLook)
    camera.CFrame = newCamCFrame

    -- Determine movement direction based on keys relative to snapped camera
    local moveDir = Vector3.new(0,0,0)
    if keysPressed.W then moveDir += horizontalLook end
    if keysPressed.S then moveDir -= horizontalLook end
    if keysPressed.A then moveDir -= rightVec end
    if keysPressed.D then moveDir += rightVec end

    if moveDir.Magnitude < 0.01 then
        -- No movement keys pressed, no rotation change needed
        return
    end

    -- Normalize moveDir for direction only
    moveDir = moveDir.Unit

    -- Handle WS flicker special case (W and S pressed together without A or D)
    if keysPressed.W and keysPressed.S and not keysPressed.A and not keysPressed.D then
        wsTimer += dt
        if wsTimer >= wsInterval then
            wsTimer = 0
            wsToggle = not wsToggle
        end
        -- flicker between forward and backward relative to snapped camera
        moveDir = wsToggle and horizontalLook or -horizontalLook
    else
        -- reset flicker timer when not WS combo
        wsTimer = 0
        wsToggle = false
    end

    -- Snap moveDir to nearest 45 degrees (8 directions)
    local moveYaw = math.atan2(moveDir.Z, moveDir.X)
    local snappedMoveYaw = snapAngle(moveYaw)
    local snappedDir = Vector3.new(math.cos(snappedMoveYaw), 0, math.sin(snappedMoveYaw))

    -- Snap avatar facing direction instantly (only rotation, keep position)
    local pos = hrp.Position
    hrp.CFrame = CFrame.new(pos, pos + snappedDir)
end)
