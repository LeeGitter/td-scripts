local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local function waitForCharacter()
	if player.Character then return player.Character end
	return player.CharacterAdded:Wait()
end

local character = waitForCharacter()
local humanoid = character:WaitForChild("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")

local TRACK_FRAME_COUNT = 3 -- start, mid, end
local activeTracks = {}

local function playChoppyTrack(track)
	if activeTracks[track] then return end
	activeTracks[track] = true
	track.Looped = false -- manually loop it if needed
	track:AdjustWeight(1, 0) -- snap in
	track:Play(0, 1, 0) -- start paused

	local length = track.Length
	if length == 0 then
		activeTracks[track] = nil
		return
	end

	-- Divide time into 3 segments
	local timestamps = {
		0,
		math.clamp(length / 2, 0, length),
		length
	}

	task.spawn(function()
		for i = 1, #timestamps do
			if not track.IsPlaying then break end
			track.TimePosition = timestamps[i]
			track:AdjustSpeed(0) -- freeze frame
			task.wait(0.1) -- hold frame
		end

		if track.IsPlaying then
			track:Stop(0) -- no blending out
		end
		activeTracks[track] = nil
	end)
end

-- Monitor tracks constantly
RunService.RenderStepped:Connect(function()
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		if not activeTracks[track] then
			playChoppyTrack(track)
		end
	end
end)

-- Clean up dead tracks
humanoid.Died:Connect(function()
	activeTracks = {}
end)

-- Character respawn support
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = character:WaitForChild("Humanoid")
	animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")
	activeTracks = {}
end)
