local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local FRAME_HOLD_TIME = 1 -- seconds per frame hold

local currentTrack = nil
local choppyData = nil
local connection = nil

local function reset()
	if connection then
		connection:Disconnect()
		connection = nil
	end
	currentTrack = nil
	choppyData = nil
end

local function startChoppy()
	reset()

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")

	connection = RunService.RenderStepped:Connect(function(dt)
		-- If no animation playing, try to get a new one
		if not currentTrack then
			for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
				if track.IsPlaying and track.Length > 0 then
					currentTrack = track
					local length = track.Length
					choppyData = {
						frames = {0, math.floor(length / 2), length - 0.05},
						index = 1,
						timer = 0,
						lastTimePosition = -1,
					}
					break
				end
			end
		end

		-- If there is a current track, snap frames
		if currentTrack and currentTrack.IsPlaying then
			choppyData.timer = choppyData.timer + dt
			if choppyData.timer >= FRAME_HOLD_TIME then
				choppyData.timer = 0
				choppyData.index = choppyData.index % #choppyData.frames + 1
				local newTime = choppyData.frames[choppyData.index]
				if math.abs(newTime - choppyData.lastTimePosition) > 0.01 then
					currentTrack.TimePosition = newTime
					choppyData.lastTimePosition = newTime
				end
			end
		else
			-- Current animation ended, clear it to allow new animations
			currentTrack = nil
			choppyData = nil
		end
	end)

	humanoid.Died:Connect(function()
		reset()
	end)
end

startChoppy()

player.CharacterAdded:Connect(function()
	startChoppy()
end)
