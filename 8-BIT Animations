local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

humanoid.AutoRotate = false

local keysPressed = {W=false,A=false,S=false,D=false}

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    local k = input.KeyCode
    if k == Enum.KeyCode.W then keysPressed.W = true end
    if k == Enum.KeyCode.A then keysPressed.A = true end
    if k == Enum.KeyCode.S then keysPressed.S = true end
    if k == Enum.KeyCode.D then keysPressed.D = true end
end)

UserInputService.InputEnded:Connect(function(input, gp)
    if gp then return end
    local k = input.KeyCode
    if k == Enum.KeyCode.W then keysPressed.W = false end
    if k == Enum.KeyCode.A then keysPressed.A = false end
    if k == Enum.KeyCode.S then keysPressed.S = false end
    if k == Enum.KeyCode.D then keysPressed.D = false end
end)

local mouseDeltaX = 0
local mouseDeltaY = 0
local sensitivity = 0.15 -- lower sensitivity for easier turning

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        mouseDeltaX = mouseDeltaX + input.Delta.X * sensitivity
        mouseDeltaY = mouseDeltaY + input.Delta.Y * sensitivity
    end
end)

local function snapAngle(angle)
    local deg = math.deg(angle)
    local snappedDeg = math.floor((deg + 22.5) / 45) * 45
    return math.rad(snappedDeg)
end

local wsToggle = false
local wsTimer = 0
local wsInterval = 0.05

-- Smooth camera yaw tracking
local camYaw, camPitch = (function(cf)
    local lv = cf.LookVector
    return math.atan2(lv.Z, lv.X), math.asin(lv.Y)
end)(camera.CFrame)

RunService.RenderStepped:Connect(function(dt)
    -- Apply mouse input to yaw/pitch
    camYaw = camYaw + math.rad(mouseDeltaX)
    camPitch = camPitch - math.rad(mouseDeltaY)
    mouseDeltaX = 0
    mouseDeltaY = 0

    -- Clamp pitch (-80 to 80 degrees)
    local maxPitch = math.rad(80)
    if camPitch > maxPitch then camPitch = maxPitch end
    if camPitch < -maxPitch then camPitch = -maxPitch end

    -- Target snapped yaw (nearest 45 deg)
    local targetYaw = snapAngle(camYaw)

    -- Smoothly interpolate yaw towards snapped yaw (ease in/out)
    local lerpSpeed = 8 -- tweak for faster/slower snapping
    local function lerp(a,b,t) return a + (b-a)*t end

    -- Handle angle wrap-around correctly:
    local diff = targetYaw - camYaw
    if diff > math.pi then diff = diff - 2*math.pi end
    if diff < -math.pi then diff = diff + 2*math.pi end

    camYaw = camYaw + diff * math.clamp(lerpSpeed * dt, 0, 1)

    -- Recompute snapped look/right vectors from smoothed camYaw
    local lookVec = Vector3.new(math.cos(camYaw), 0, math.sin(camYaw))
    local rightVec = Vector3.new(-lookVec.Z, 0, lookVec.X)

    -- Build smooth camera look vector with pitch
    local lookVector = (CFrame.fromAxisAngle(rightVec, camPitch) * CFrame.lookAt(Vector3.new(), lookVec)).LookVector
    camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + lookVector)

    -- Movement vector based on keys and snapped direction (no smooth circle)
    local moveVec = Vector3.new(0,0,0)
    if keysPressed.W then moveVec += lookVec end
    if keysPressed.S then moveVec -= lookVec end
    if keysPressed.A then moveVec -= rightVec end
    if keysPressed.D then moveVec += rightVec end

    if moveVec.Magnitude < 0.01 then
        return
    end
    moveVec = moveVec.Unit

    -- WS flicker toggle for W+S only (no A or D)
    if keysPressed.W and keysPressed.S and not keysPressed.A and not keysPressed.D then
        wsTimer = wsTimer + dt
        if wsTimer >= wsInterval then
            wsTimer = 0
            wsToggle = not wsToggle
        end
        moveVec = wsToggle and lookVec or -lookVec
    else
        wsTimer = 0
        wsToggle = false
    end

    -- Snap moveVec to nearest 45 deg to prevent smooth circling
    local moveYaw = math.atan2(moveVec.Z, moveVec.X)
    local snappedMoveYaw = snapAngle(moveYaw)
    local snappedMoveDir = Vector3.new(math.cos(snappedMoveYaw), 0, math.sin(snappedMoveYaw))

    -- Snap avatar facing rotation
    local pos = hrp.Position
    hrp.CFrame = CFrame.new(pos, pos + snappedMoveDir)
end)
