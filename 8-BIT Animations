local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

local FRAME_HOLD_TIME = 0.3 -- seconds per frame hold

local choppyTracks = {}
local connection = nil

local function getKeyframeTimes(animation)
	local keyframeSequence = animation:GetKeyframeSequence()
	if not keyframeSequence then return {0} end

	local keyframes = keyframeSequence.Keyframes
	local times = {}
	for _, kf in ipairs(keyframes) do
		table.insert(times, kf.Time)
	end
	table.sort(times)
	return times
end

local function reset()
	if connection then
		connection:Disconnect()
		connection = nil
	end
	choppyTracks = {}
end

local function startChoppy()
	reset()

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")

	connection = RunService.RenderStepped:Connect(function(dt)
		-- Add new tracks
		for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
			if not choppyTracks[track] then
				local anim = track.Animation
				if anim and track.Length > 0 then
					local frames = getKeyframeTimes(anim)
					if #frames >= 3 then
						choppyTracks[track] = {
							frames = {frames[1], frames[math.floor(#frames / 2)], frames[#frames]},
							index = 1,
							timer = 0,
						}
					end
				end
			end
		end

		-- Update existing tracks
		for track, data in pairs(choppyTracks) do
			if not track.IsPlaying then
				choppyTracks[track] = nil
			else
				data.timer = data.timer + dt
				if data.timer >= FRAME_HOLD_TIME then
					data.timer = 0
					data.index = data.index % #data.frames + 1
					track.TimePosition = data.frames[data.index]
				end
			end
		end
	end)

	humanoid.Died:Connect(function()
		reset()
	end)
end

-- Start initially
startChoppy()

-- Restart on respawn
player.CharacterAdded:Connect(function()
	startChoppy()
end)
