local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

local FRAME_HOLD_TIME = 0.5 -- seconds per frame hold

local choppyTracks = {}
local connection = nil

local function reset()
	if connection then
		connection:Disconnect()
		connection = nil
	end
	choppyTracks = {}
end

local function startChoppy()
	reset()

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")

	connection = RunService.RenderStepped:Connect(function(dt)
		for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
			if not choppyTracks[track] and track.Length > 0 then
				choppyTracks[track] = {
					frames = {0, math.min(track.Length / 2, track.Length - 0.05)}, -- avoid exact end to prevent glitches
					index = 1,
					timer = 0,
				}
			end
		end

		for track, data in pairs(choppyTracks) do
			if not track.IsPlaying then
				choppyTracks[track] = nil
			else
				data.timer = data.timer + dt
				if data.timer >= FRAME_HOLD_TIME then
					data.timer = 0
					data.index = data.index % #data.frames + 1
					local frameTime = data.frames[data.index]
					-- Clamp frameTime just before the animation end to avoid looping glitches
					if frameTime >= track.Length then
						frameTime = track.Length - 0.05
					end
					track.TimePosition = frameTime
				end
			end
		end
	end)

	humanoid.Died:Connect(function()
		reset()
	end)
end

startChoppy()

player.CharacterAdded:Connect(function()
	startChoppy()
end)
