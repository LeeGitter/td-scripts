local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local function waitForCharacter()
	return player.Character or player.CharacterAdded:Wait()
end

local function getAnimator()
	local character = waitForCharacter()
	local humanoid = character:WaitForChild("Humanoid")
	return humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")
end

local activeTracks = {}
local choppyState = {}

-- How many distinct time positions we want to show per animation
local FRAME_SEGMENTS = 3
local FRAME_HOLD_TIME = 0.12 -- how long to hold each frame

local function getFrameTimes(length)
	if length == 0 then
		return {0}
	end
	local times = {}
	for i = 0, FRAME_SEGMENTS - 1 do
		table.insert(times, (length / (FRAME_SEGMENTS - 1)) * i)
	end
	return times
end

-- Main logic: loop over animations and force them to show only a few frames
RunService.RenderStepped:Connect(function()
	local animator = getAnimator()
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		if not choppyState[track] then
			choppyState[track] = {
				frameTimes = getFrameTimes(track.Length),
				currentIndex = 1,
				timer = 0,
			}
			track:AdjustSpeed(0) -- freeze immediately
			track.TimePosition = choppyState[track].frameTimes[1]
		end
	end

	for track, state in pairs(choppyState) do
		if not track.IsPlaying then
			choppyState[track] = nil
		else
			state.timer += RunService.RenderStepped:Wait()
			if state.timer >= FRAME_HOLD_TIME then
				state.timer = 0
				state.currentIndex = (state.currentIndex % #state.frameTimes) + 1
				track.TimePosition = state.frameTimes[state.currentIndex]
			end
			track:AdjustSpeed(0) -- keep frozen
		end
	end
end)

-- Reset when character respawns
Players.LocalPlayer.CharacterAdded:Connect(function()
	choppyState = {}
end)
