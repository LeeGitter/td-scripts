local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

humanoid.AutoRotate = false

local keysPressed = {
    W = false,
    A = false,
    S = false,
    D = false,
}

-- Variables to track mouse delta for yaw and pitch
local mouseDeltaX = 0
local mouseDeltaY = 0

-- Sensitivity (tweak to taste)
local sensitivity = 0.3

-- Current camera yaw and pitch (in radians)
-- Initialize to current camera angles
local function getYawPitchFromCFrame(cf)
    local lookVector = cf.LookVector
    local yaw = math.atan2(lookVector.Z, lookVector.X)
    local pitch = math.asin(lookVector.Y)
    return yaw, pitch
end

local camYaw, camPitch = getYawPitchFromCFrame(camera.CFrame)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = true end
    if key == Enum.KeyCode.A then keysPressed.A = true end
    if key == Enum.KeyCode.S then keysPressed.S = true end
    if key == Enum.KeyCode.D then keysPressed.D = true end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = false end
    if key == Enum.KeyCode.A then keysPressed.A = false end
    if key == Enum.KeyCode.S then keysPressed.S = false end
    if key == Enum.KeyCode.D then keysPressed.D = false end
end)

-- Capture relative mouse movement for smooth yaw/pitch changes
UserInputService.InputChanged:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        mouseDeltaX = mouseDeltaX + input.Delta.X * sensitivity
        mouseDeltaY = mouseDeltaY + input.Delta.Y * sensitivity
    end
end)

-- Snap angle to nearest 45 degrees (in radians)
local function snapAngle(angle)
    local deg = math.deg(angle)
    local snappedDeg = math.floor((deg + 22.5) / 45) * 45
    return math.rad(snappedDeg)
end

local wsToggle = false
local wsTimer = 0
local wsInterval = 0.05

RunService.RenderStepped:Connect(function(dt)
    -- Update camera yaw and pitch by mouse delta
    camYaw = camYaw + math.rad(mouseDeltaX)
    camPitch = camPitch - math.rad(mouseDeltaY)

    -- Clamp pitch so player can't flip camera upside down (between -80 and 80 degrees)
    local pitchLimit = math.rad(80)
    if camPitch > pitchLimit then camPitch = pitchLimit end
    if camPitch < -pitchLimit then camPitch = -pitchLimit end

    -- Reset mouse deltas after applying
    mouseDeltaX = 0
    mouseDeltaY = 0

    -- Snap camera yaw to nearest 45 degrees (8 directions)
    local snappedYaw = snapAngle(camYaw)

    -- Build camera right and snapped look vectors
    local snappedLook = Vector3.new(math.cos(snappedYaw), 0, math.sin(snappedYaw))
    local camRight = Vector3.new(-snappedLook.Z, 0, snappedLook.X)

    -- Build camera look vector with snapped yaw but smooth pitch
    local newLookVector = (CFrame.fromAxisAngle(camRight, camPitch) * CFrame.lookAt(Vector3.new(), snappedLook)).LookVector

    -- Set camera CFrame to snapped yaw + smooth pitch
    local camPos = camera.CFrame.Position
    camera.CFrame = CFrame.new(camPos, camPos + newLookVector)

    -- Build move vector relative to snapped camera direction
    local moveVector = Vector3.new(0, 0, 0)
    if keysPressed.W then moveVector += snappedLook end
    if keysPressed.S then moveVector -= snappedLook end
    if keysPressed.A then moveVector -= camRight end
    if keysPressed.D then moveVector += camRight end

    if moveVector.Magnitude < 0.01 then
        -- No movement input, do nothing
        return
    end

    moveVector = moveVector.Unit

    -- WS flicker toggle (only when W and S pressed without A or D)
    if keysPressed.W and keysPressed.S and not keysPressed.A and not keysPressed.D then
        wsTimer = wsTimer + dt
        if wsTimer >= wsInterval then
            wsTimer = 0
            wsToggle = not wsToggle
        end
        moveVector = wsToggle and snappedLook or -snappedLook
    else
        wsTimer = 0
        wsToggle = false
    end

    -- Snap move vector to nearest 45 degrees to prevent smooth circle movement
    local moveYaw = math.atan2(moveVector.Z, moveVector.X)
    local snappedMoveYaw = snapAngle(moveYaw)
    local snappedMoveDir = Vector3.new(math.cos(snappedMoveYaw), 0, math.sin(snappedMoveYaw))

    -- Snap avatar facing direction (only rotation, keep position)
    local hrpPos = hrp.Position
    hrp.CFrame = CFrame.new(hrpPos, hrpPos + snappedMoveDir)
end)
