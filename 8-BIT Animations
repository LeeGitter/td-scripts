local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

humanoid.AutoRotate = false

local keysPressed = {
    W = false,
    A = false,
    S = false,
    D = false,
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = true end
    if key == Enum.KeyCode.A then keysPressed.A = true end
    if key == Enum.KeyCode.S then keysPressed.S = true end
    if key == Enum.KeyCode.D then keysPressed.D = true end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then keysPressed.W = false end
    if key == Enum.KeyCode.A then keysPressed.A = false end
    if key == Enum.KeyCode.S then keysPressed.S = false end
    if key == Enum.KeyCode.D then keysPressed.D = false end
end)

-- Function to snap an angle (in radians) to nearest 45 degrees (8 directions)
local function snapAngle(angle)
    local degree = math.deg(angle)
    local snappedDegree = math.floor((degree + 22.5) / 45) * 45
    return math.rad(snappedDegree)
end

-- Direction vectors for WASD combos relative to camera forward/right
local function getInputDirection(camCFrame, keys)
    local forward = camCFrame.LookVector
    forward = Vector3.new(forward.X, 0, forward.Z).Unit
    local right = camCFrame.RightVector
    right = Vector3.new(right.X, 0, right.Z).Unit
    
    local moveDir = Vector3.new(0,0,0)
    if keys.W then moveDir += forward end
    if keys.S then moveDir -= forward end
    if keys.A then moveDir -= right end
    if keys.D then moveDir += right end
    
    if moveDir.Magnitude > 0 then
        return moveDir.Unit
    else
        return nil
    end
end

local wsToggle = false
local wsTimer = 0
local wsInterval = 0.05

RunService.RenderStepped:Connect(function(dt)
    local cam = camera.CFrame
    
    -- Snap camera yaw to nearest 45 degrees
    local camLookVector = Vector3.new(cam.LookVector.X, 0, cam.LookVector.Z).Unit
    local camYaw = math.atan2(camLookVector.Z, camLookVector.X)
    local snappedYaw = snapAngle(camYaw)
    
    -- Rebuild camera CFrame with snapped yaw but keep camera pitch (look up/down)
    local camPos = cam.Position
    local camPitch = math.asin(cam.LookVector.Y)
    local snappedLookVector = Vector3.new(math.cos(snappedYaw), 0, math.sin(snappedYaw))
    local camRight = Vector3.new(-snappedLookVector.Z, 0, snappedLookVector.X)
    
    -- Construct new camera CFrame with snapped yaw but original pitch
    local newCamLook = (CFrame.fromAxisAngle(camRight, camPitch) * CFrame.lookAt(Vector3.new(), snappedLookVector)).LookVector
    local newCamCFrame = CFrame.new(camPos, camPos + newCamLook)
    camera.CFrame = newCamCFrame
    
    -- Get input direction relative to snapped camera
    local moveDir = getInputDirection(camera.CFrame, keysPressed)
    if not moveDir then
        return
    end
    
    -- Handle WS combo flicker toggle (forward/back)
    if keysPressed.W and keysPressed.S and not keysPressed.A and not keysPressed.D then
        wsTimer += dt
        if wsTimer >= wsInterval then
            wsTimer = 0
            wsToggle = not wsToggle
        end
        moveDir = wsToggle and Vector3.new(0,0,-1) or Vector3.new(0,0,1)
        -- Transform this relative to camera snapped yaw
        local forward = Vector3.new(math.cos(snappedYaw), 0, math.sin(snappedYaw))
        moveDir = wsToggle and forward or -forward
    end
    
    -- Snap moveDir to nearest 8 directions relative to camera yaw
    local moveYaw = math.atan2(moveDir.Z, moveDir.X)
    local snappedMoveYaw = snapAngle(moveYaw)
    local snappedDir = Vector3.new(math.cos(snappedMoveYaw), 0, math.sin(snappedMoveYaw))
    
    -- Snap character facing direction
    local pos = hrp.Position
    hrp.CFrame = CFrame.new(pos, pos + snappedDir)
end)
