local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local activeTracks = {}
local stopEffect = false
local connections = {}

-- Constantly update the activeTracks list
local function updateTracks()
	local current = humanoid:GetPlayingAnimationTracks()
	for _, track in ipairs(current) do
		if not table.find(activeTracks, track) and track.IsPlaying then
			table.insert(activeTracks, track)
		end
	end

	-- Remove non-playing tracks
	for i = #activeTracks, 1, -1 do
		if not activeTracks[i].IsPlaying then
			table.remove(activeTracks, i)
		end
	end
end

-- Start update loop
task.spawn(function()
	while not stopEffect do
		updateTracks()
		task.wait(0.1)
	end
end)

-- Main frame-skip loop
task.spawn(function()
	while not stopEffect do
		-- Pause animations
		for _, track in ipairs(activeTracks) do
			pcall(function()
				track:AdjustSpeed(0)
			end)
		end
		task.wait(0.45)

		-- Briefly unpause
		for _, track in ipairs(activeTracks) do
			pcall(function()
				track:AdjustSpeed(1)
			end)
		end
		task.wait(0.05)
	end
end)

-- Cleanup on respawn
table.insert(connections, player.CharacterAdded:Connect(function()
	stopEffect = true
	for _, conn in ipairs(connections) do
		pcall(function()
			conn:Disconnect()
		end)
	end
end))
