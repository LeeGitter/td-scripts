local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

local anim1 = Instance.new("Animation")
anim1.AnimationId = "rbxassetid://105660804989893"
local anim2 = Instance.new("Animation")
anim2.AnimationId = "rbxassetid://123691762461584"

local animTrack1, animTrack2, runAnimTrack
local holding = false
local running = false
local timeHeld = 0
local cooldown = false
local cooldownTime = 25

-- GUI Setup
local cooldownGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
cooldownGui.Name = "DriftCooldownGui"
local cooldownLabel = Instance.new("TextLabel", cooldownGui)
cooldownLabel.Size = UDim2.new(0, 60, 0, 20)
cooldownLabel.Position = UDim2.new(1, -70, 0.5, -110)
cooldownLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
cooldownLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
cooldownLabel.Font = Enum.Font.Code
cooldownLabel.TextSize = 14
cooldownLabel.Text = "Ready"

local function startCooldown()
	cooldown = true
	local t = cooldownTime
	coroutine.wrap(function()
		while t > 0 do
			cooldownLabel.Text = string.format("%.1f", t)
			RunService.Heartbeat:Wait()
			t -= RunService.Heartbeat:Wait()
		end
		cooldown = false
		cooldownLabel.Text = "Ready"
	end)()
end

UIS.InputBegan:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.T or holding or cooldown then return end

	-- Begin charge
	holding = true
	timeHeld = 0
	humanoid.WalkSpeed = 0
	humanoid.AutoRotate = false

	animTrack1 = humanoid:LoadAnimation(anim1)
	animTrack1:Play()
	animTrack1:AdjustSpeed(1)

	local startTime = tick()
	while holding do
		RunService.RenderStepped:Wait()
		timeHeld = tick() - startTime

		-- First anim speed ramp (1x to 2x)
		if timeHeld <= 2.5 then
			local speed = 1 + (1 * (timeHeld / 2.5))
			if animTrack1 then animTrack1:AdjustSpeed(speed) end
		end

		-- Switch to second animation
		if timeHeld > 2.5 and animTrack1 then
			animTrack1:Stop()
			animTrack1 = nil
			animTrack2 = humanoid:LoadAnimation(anim2)
			animTrack2:Play()
		end

		-- Second anim speed ramp (1x to 2x)
		if timeHeld > 2.5 and timeHeld <= 4 and animTrack2 then
			local speed = 1 + ((timeHeld - 2.5) / 1.5)
			animTrack2:AdjustSpeed(speed)
		end
	end
end)

UIS.InputEnded:Connect(function(input)
	if input.KeyCode ~= Enum.KeyCode.T or not holding then return end

	-- End charge
	holding = false
	startCooldown()

	if animTrack1 then animTrack1:Stop() end
	if animTrack2 then animTrack2:Stop() end

	-- Begin drift-run mode
	humanoid.WalkSpeed = 100
	humanoid.AutoRotate = false
	running = true

	runAnimTrack = humanoid:LoadAnimation(anim2)
	runAnimTrack:Play()
	runAnimTrack:AdjustSpeed(4)

	local driftConn
	local runTime = 5
	local decayStart = 3.5
	local decayDuration = runTime - decayStart
	local startTime = tick()
	local currentDir = hrp.CFrame.LookVector

	driftConn = RunService.RenderStepped:Connect(function()
		if not running then driftConn:Disconnect() return end

		local elapsed = tick() - startTime
		if elapsed >= runTime then
			running = false
			humanoid.WalkSpeed = 16
			humanoid.AutoRotate = true
			if runAnimTrack then runAnimTrack:Stop() end
			driftConn:Disconnect()
			return
		end

		-- Animate decay from 4x to 1x
		if runAnimTrack then
			if elapsed <= decayStart then
				runAnimTrack:AdjustSpeed(4)
			else
				local progress = (elapsed - decayStart) / decayDuration
				local speed = 4 - (3 * progress)
				runAnimTrack:AdjustSpeed(math.clamp(speed, 1, 4))
			end
		end

		-- Get camera basis vectors flattened on XZ plane
		local camCF = Camera.CFrame
		local forward = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z)
		local right = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z)

		-- Normalize to avoid zero length
		forward = forward.Magnitude > 0 and forward.Unit or Vector3.new(0, 0, -1)
		right = right.Magnitude > 0 and right.Unit or Vector3.new(1, 0, 0)

		-- Movement input vector from keys
		local moveVec = Vector3.new(0, 0, 0)
		if UIS:IsKeyDown(Enum.KeyCode.W) then
			moveVec += forward
		end
		if UIS:IsKeyDown(Enum.KeyCode.A) then
			moveVec -= right
		end
		if UIS:IsKeyDown(Enum.KeyCode.D) then
			moveVec += right
		end

		-- If no input, default forward
		if moveVec.Magnitude == 0 then
			moveVec = forward
		else
			moveVec = moveVec.Unit
		end

		-- Smoothly lerp drift direction to input direction
		currentDir = currentDir:Lerp(moveVec, 0.1)

		-- Move humanoid and rotate character to face drift direction
		humanoid:Move(currentDir, false)
		local lookAt = CFrame.new(hrp.Position, hrp.Position + currentDir)
		hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(lookAt.LookVector.X, 0, lookAt.LookVector.Z) + hrp.Position)
	end)
end)

-- Reset on death
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")
	holding = false
	running = false
	humanoid.WalkSpeed = 16
	humanoid.AutoRotate = true
end)
