local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

local anim1 = Instance.new("Animation")
anim1.AnimationId = "rbxassetid://105660804989893"
local anim2 = Instance.new("Animation")
anim2.AnimationId = "rbxassetid://123691762461584"

local animTrack1, animTrack2, runAnimTrack
local holding = false
local running = false
local timeHeld = 0
local cooldown = false
local cooldownTime = 25

-- GUI Setup
local cooldownGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
cooldownGui.Name = "DriftCooldownGui"
local cooldownLabel = Instance.new("TextLabel", cooldownGui)
cooldownLabel.Size = UDim2.new(0, 60, 0, 20)
cooldownLabel.Position = UDim2.new(1, -70, 0.5, -110)
cooldownLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
cooldownLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
cooldownLabel.Font = Enum.Font.Code
cooldownLabel.TextSize = 14
cooldownLabel.Text = "Ready"

local function startCooldown(seconds)
	cooldown = true
	local start = tick()
	coroutine.wrap(function()
		while tick() - start < seconds do
			local remaining = seconds - (tick() - start)
			cooldownLabel.Text = string.format("%.1f", remaining)
			RunService.Heartbeat:Wait()
		end
		cooldown = false
		cooldownLabel.Text = "Ready"
	end)()
end

local fourXStartTime = nil
local fourXTimeAccumulated = 0

UIS.InputBegan:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.T or holding or cooldown then return end

	holding = true
	timeHeld = 0
	fourXStartTime = nil
	fourXTimeAccumulated = 0
	humanoid.AutoRotate = false
	humanoid.WalkSpeed = 0

	animTrack1 = humanoid:LoadAnimation(anim1)
	animTrack1:Play()
	animTrack1:AdjustSpeed(1)

	local startTime = tick()
	while holding do
		RunService.RenderStepped:Wait()
		timeHeld = tick() - startTime

		if timeHeld <= 2.5 then
			local speed = 1 + (1 * (timeHeld / 2.5))
			if animTrack1 then animTrack1:AdjustSpeed(speed) end
		end

		if timeHeld > 2.5 and animTrack1 then
			animTrack1:Stop()
			animTrack1 = nil
			animTrack2 = humanoid:LoadAnimation(anim2)
			animTrack2:Play()
		end

		if timeHeld > 2.5 and timeHeld <= 4 and animTrack2 then
			local speed = 1 + ((timeHeld - 2.5) / 1.5)
			animTrack2:AdjustSpeed(speed)
		end

		if timeHeld > 3.5 and animTrack2 then
			animTrack2:AdjustSpeed(4)
			if not fourXStartTime then
				fourXStartTime = tick()
			end
			fourXTimeAccumulated = tick() - fourXStartTime
		end
	end
end)

UIS.InputEnded:Connect(function(input)
	if input.KeyCode ~= Enum.KeyCode.T or not holding then return end

	holding = false

	if animTrack1 then animTrack1:Stop() end
	if animTrack2 then animTrack2:Stop() end

	local allowDash = fourXTimeAccumulated >= 1

	if not allowDash then
		startCooldown(10)
		humanoid.WalkSpeed = 16
		humanoid.AutoRotate = true
		return
	end

	startCooldown(25)

	-- Start spoofed dash using BodyVelocity
	local runTime = 5
	local decayStart = 3.5
	local decayDuration = runTime - decayStart
	local startTime = tick()
	local currentDir = hrp.CFrame.LookVector
	humanoid.AutoRotate = false
	running = true

	runAnimTrack = humanoid:LoadAnimation(anim2)
	runAnimTrack:Play()
	runAnimTrack:AdjustSpeed(4)

	local bodyVel = Instance.new("BodyVelocity")
	bodyVel.MaxForce = Vector3.new(1e5, 0, 1e5)
	bodyVel.P = 1500
	bodyVel.Velocity = Vector3.zero
	bodyVel.Parent = hrp

	local driftConn
	driftConn = RunService.RenderStepped:Connect(function(dt)
		if not running then driftConn:Disconnect() return end

		local elapsed = tick() - startTime
		if elapsed >= runTime then
			running = false
			bodyVel:Destroy()
			humanoid.AutoRotate = true
			if runAnimTrack then runAnimTrack:Stop() end
			driftConn:Disconnect()
			return
		end

		if runAnimTrack then
			if elapsed <= decayStart then
				runAnimTrack:AdjustSpeed(4)
			else
				local progress = (elapsed - decayStart) / decayDuration
				local speed = 4 - (3 * progress)
				runAnimTrack:AdjustSpeed(math.clamp(speed, 1, 4))
			end
		end

		local camCF = Camera.CFrame
		local forward = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z).Unit
		local right = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z).Unit

		local moveVec = Vector3.zero
		if UIS:IsKeyDown(Enum.KeyCode.W) then
			moveVec += forward
		end
		if UIS:IsKeyDown(Enum.KeyCode.A) then
			moveVec -= right
		end
		if UIS:IsKeyDown(Enum.KeyCode.D) then
			moveVec += right
		end
		if moveVec.Magnitude == 0 then
			moveVec = forward
		else
			moveVec = moveVec.Unit
		end

		currentDir = currentDir:Lerp(moveVec, 0.05)

		-- ðŸ”§ Use BodyVelocity to simulate spoofed dash
		local targetSpeed = 2
		bodyVel.Velocity = currentDir * targetSpeed

		-- Face direction
		local newLook = hrp.Position + currentDir
		hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(newLook.X, hrp.Position.Y, newLook.Z))
	end)
end)

-- Reset on respawn
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")
	holding = false
	running = false
	humanoid.WalkSpeed = 16
	humanoid.AutoRotate = true
end)
