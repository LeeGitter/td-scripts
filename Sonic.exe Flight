local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- State
local flying = false
local descending = false
local maxSpeed = 75
local startSpeed = 10
local acceleration = 0.15
local deceleration = 0.4
local descentSpeed = 40
local currentSpeed = 0
local moveDir = Vector3.zero

-- Animation IDs
local anims = {
	idle = "rbxassetid://101166618473023",
	slow = "rbxassetid://81150683491044",
	fast = "rbxassetid://131369481104313",
	land = "rbxassetid://92837953970970"
}

-- Animator
local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

-- Load animations
local tracks = {}
for name, id in pairs(anims) do
	local anim = Instance.new("Animation")
	anim.AnimationId = id
	tracks[name] = animator:LoadAnimation(anim)
end

-- Stop all flight-related animations
local function stopAllFlightAnimations()
	for _, track in pairs(tracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
end

-- Smooth tilt helper: tilt avatar towards movement direction
local function tiltBodyTowards(dir, dt)
	if dir.Magnitude > 0 then
		local currentCF = hrp.CFrame
		local goalCF = CFrame.new(hrp.Position, hrp.Position + dir)
		hrp.CFrame = currentCF:Lerp(goalCF, dt * 2.5)
	end
end

-- Movement key tracking
local moveKeys = {
	[Enum.KeyCode.W] = Vector3.new(0, 0, -1),
	[Enum.KeyCode.S] = Vector3.new(0, 0, 1),
	[Enum.KeyCode.A] = Vector3.new(-1, 0, 0),
	[Enum.KeyCode.D] = Vector3.new(1, 0, 0),
}
local heldKeys = {}

UserInputService.InputBegan:Connect(function(input, gpe)
	if not gpe and moveKeys[input.KeyCode] then
		heldKeys[input.KeyCode] = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if moveKeys[input.KeyCode] then
		heldKeys[input.KeyCode] = nil
	end
end)

-- Movement direction based on camera orientation (standard WASD)
local function getMoveDirection()
	local camCF = workspace.CurrentCamera.CFrame
	local forward = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z).Unit
	local right = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z).Unit
	local direction = Vector3.zero

	for key, _ in pairs(heldKeys) do
		if moveKeys[key] then
			direction += (moveKeys[key].Z * forward + moveKeys[key].X * right)
		end
	end

	if direction.Magnitude > 0 then
		return direction.Unit
	end
	return Vector3.zero
end

-- Start flight
local function startFlight()
	if flying then return end
	flying = true
	descending = false
	currentSpeed = startSpeed

	-- Quick upward boost (4 studs)
	local goalPos = hrp.Position + Vector3.new(0, 4, 0)
	local floatTween = TweenService:Create(hrp, TweenInfo.new(0.15, Enum.EasingStyle.Sine), {CFrame = CFrame.new(goalPos)})
	floatTween:Play()
	floatTween.Completed:Wait()

	humanoid.WalkSpeed = 0

	-- Begin flight control loop
	RunService:BindToRenderStep("FlightControl", Enum.RenderPriority.Input.Value, function(dt)
		local inputDir = getMoveDirection()

		if inputDir.Magnitude > 0 then
			moveDir = inputDir
			currentSpeed = math.min(maxSpeed, currentSpeed + acceleration)
		else
			currentSpeed = math.max(0, currentSpeed - deceleration)
		end

		local moveVector = moveDir * currentSpeed
		hrp.Velocity = moveVector + Vector3.new(0, 0, 0) -- preserve only horizontal velocity; you can add vertical if needed

		-- Tilt avatar smoothly to movement direction (based on camera movement)
		tiltBodyTowards(moveVector, dt)

		stopAllFlightAnimations()
		if currentSpeed < 1 then
			tracks.idle:Play()
		elseif currentSpeed < 30 then
			tracks.slow:Play()
		else
			tracks.fast:Play()
		end
	end)
end

-- Start descent
local function startDescent()
	if not flying or descending then return end
	descending = true
	RunService:UnbindFromRenderStep("FlightControl")

	local camCF = workspace.CurrentCamera.CFrame
	local descendDir = (Vector3.new(camCF.LookVector.X, -1, camCF.LookVector.Z)).Unit

	RunService:BindToRenderStep("DescentControl", Enum.RenderPriority.Input.Value, function(dt)
		local fallVelocity = descendDir * descentSpeed
		hrp.Velocity = fallVelocity

		tiltBodyTowards(descendDir, dt)

		-- Ground check with raycast
		local ray = Ray.new(hrp.Position, Vector3.new(0, -3, 0))
		local hit = workspace:FindPartOnRay(ray, character)
		if hit then
			stopAllFlightAnimations()
			RunService:UnbindFromRenderStep("DescentControl")

			tracks.land:Play()
			task.wait(tracks.land.Length or 1)

			humanoid.WalkSpeed = 45
			flying = false
			descending = false
			currentSpeed = 0
			moveDir = Vector3.zero
		end
	end)
end

-- Toggle flight with T
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.T then
		if not flying then
			startFlight()
		elseif not descending then
			startDescent()
		end
	end
end)
