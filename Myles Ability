--// Services
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

--// Setup
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

--// Animations
local descentAnim = Instance.new("Animation")
descentAnim.AnimationId = "rbxassetid://77249297287605"

local launchAnim = Instance.new("Animation")
launchAnim.AnimationId = "rbxassetid://84493272045483"

local descentTrack = humanoid:LoadAnimation(descentAnim)
local launchTrack = humanoid:LoadAnimation(launchAnim)

descentTrack.Priority = Enum.AnimationPriority.Action4
launchTrack.Priority = Enum.AnimationPriority.Action4

--// State
local descending = false
local descentForce = nil
local spaceHeld = false
local descentConnection = nil

--// Clean physics
local function purgePhysics()
    for _, obj in ipairs(rootPart:GetChildren()) do
        if obj:IsA("BodyVelocity") or obj:IsA("BodyForce") or obj:IsA("BodyPosition") or obj:IsA("BodyGyro") then
            obj:Destroy()
        end
    end
end

--// Cancel descent
local function cancelDescent()
    if descending then
        descending = false
        if descentForce then descentForce:Destroy() end
        if descentTrack.IsPlaying then descentTrack:Stop() end
        if descentConnection then descentConnection:Disconnect() end
    end
end

--// Ground dash after descent
local function groundDash()
    local dashDuration = 3
    local dashSpeed = 40
    local startTime = tick()

    if not descentTrack.IsPlaying then
        descentTrack:Play()
        descentTrack:AdjustSpeed(1)
    end

    local velocity = Instance.new("BodyVelocity")
    velocity.MaxForce = Vector3.new(1e5, 0, 1e5)
    velocity.P = 1000
    velocity.Velocity = rootPart.CFrame.LookVector * dashSpeed
    velocity.Parent = rootPart

    local gyro = Instance.new("BodyGyro")
    gyro.MaxTorque = Vector3.new(0, 1e5, 0)
    gyro.P = 3000
    gyro.CFrame = rootPart.CFrame
    gyro.Parent = rootPart

    local dashConnection
    dashConnection = RunService.RenderStepped:Connect(function()
        local elapsed = tick() - startTime
        if elapsed >= dashDuration then
            dashConnection:Disconnect()
            velocity:Destroy()
            gyro:Destroy()
            descentTrack:Stop()
            return
        end

        local moveDirection = Vector3.zero
        if UIS:IsKeyDown(Enum.KeyCode.A) then moveDirection += Vector3.new(-1, 0, 0) end
        if UIS:IsKeyDown(Enum.KeyCode.D) then moveDirection += Vector3.new(1, 0, 0) end

        local currentLook = rootPart.CFrame.LookVector
        if moveDirection.Magnitude > 0 then
            local turnAngle = moveDirection.X * math.rad(90)
            local rotated = CFrame.Angles(0, turnAngle * RunService.RenderStepped:Wait(), 0)
            local newLook = (rotated * currentLook).Unit
            gyro.CFrame = CFrame.new(rootPart.Position, rootPart.Position + newLook)
            velocity.Velocity = newLook * dashSpeed
        else
            gyro.CFrame = CFrame.new(rootPart.Position, rootPart.Position + currentLook)
            velocity.Velocity = currentLook * dashSpeed
        end
    end)
end

--// Start descent
local function startDescent()
    if descending or humanoid.FloorMaterial ~= Enum.Material.Air then return end

    descending = true
    purgePhysics()

    descentTrack:Play()
    descentTrack:AdjustSpeed(4)

    descentForce = Instance.new("BodyVelocity")
    descentForce.MaxForce = Vector3.new(0, 1e5, 0)
    descentForce.P = 10000
    descentForce.Velocity = Vector3.new(0, -2, 0)
    descentForce.Parent = rootPart

    descentConnection = RunService.RenderStepped:Connect(function()
        if not descending then return end

        if humanoid.FloorMaterial ~= Enum.Material.Air then
            cancelDescent()
            groundDash()
            return
        end

        local descentSpeed = spaceHeld and -15 or -2
        descentForce.Velocity = Vector3.new(0, descentSpeed, 0)
    end)
end

--// Input detection
UIS.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        spaceHeld = true
    end

    if input.KeyCode == Enum.KeyCode.E then
        if humanoid.FloorMaterial == Enum.Material.Air then
            if descending then
                cancelDescent()
            else
                startDescent()
            end
        end
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        spaceHeld = false
    end
end)
