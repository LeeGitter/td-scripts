local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local screenGui = script.Parent

-- === Create movable GUI box ===
local boxSize = UDim2.new(0, 400, 0, 220)

local guiBox = Instance.new("Frame")
guiBox.Name = "GuiBox"
guiBox.Size = boxSize
guiBox.Position = UDim2.new(0.5, -boxSize.X.Offset/2, 0.5, -boxSize.Y.Offset/2)
guiBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
guiBox.BorderSizePixel = 0
guiBox.Active = true
guiBox.Draggable = false -- we'll do custom drag
guiBox.Parent = screenGui

-- Top bar for dragging
local dragBar = Instance.new("Frame")
dragBar.Name = "DragBar"
dragBar.Size = UDim2.new(1, 0, 0, 30)
dragBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
dragBar.BorderSizePixel = 0
dragBar.Parent = guiBox

local dragText = Instance.new("TextLabel")
dragText.Text = "FNF Chart Loader"
dragText.Font = Enum.Font.SourceSansBold
dragText.TextSize = 18
dragText.TextColor3 = Color3.new(1,1,1)
dragText.BackgroundTransparency = 1
dragText.Size = UDim2.new(1, 0, 1, 0)
dragText.Parent = dragBar

-- TextBox for JSON input
local jsonInput = Instance.new("TextBox")
jsonInput.Name = "JSONInput"
jsonInput.Size = UDim2.new(1, -20, 0, 140)
jsonInput.Position = UDim2.new(0, 10, 0, 40)
jsonInput.TextWrapped = true
jsonInput.MultiLine = true
jsonInput.ClearTextOnFocus = false
jsonInput.PlaceholderText = "Paste full FNF JSON here"
jsonInput.BackgroundColor3 = Color3.fromRGB(30,30,30)
jsonInput.TextColor3 = Color3.new(1,1,1)
jsonInput.Font = Enum.Font.SourceSans
jsonInput.TextSize = 14
jsonInput.Parent = guiBox

-- Checkmark button to load/start
local loadButton = Instance.new("TextButton")
loadButton.Name = "LoadButton"
loadButton.Size = UDim2.new(0, 100, 0, 30)
loadButton.Position = UDim2.new(0.5, -50, 1, -40)
loadButton.Text = "✔ Load Song"
loadButton.BackgroundColor3 = Color3.fromRGB(70, 130, 70)
loadButton.TextColor3 = Color3.new(1,1,1)
loadButton.Font = Enum.Font.SourceSansBold
loadButton.TextSize = 18
loadButton.Parent = guiBox

-- === Chart display (full screen behind the box) ===
local chartDisplayFrame = Instance.new("Frame")
chartDisplayFrame.Name = "ChartDisplay"
chartDisplayFrame.Size = UDim2.new(1, 0, 1, 0)
chartDisplayFrame.Position = UDim2.new(0, 0, 0, 0)
chartDisplayFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
chartDisplayFrame.BorderSizePixel = 0
chartDisplayFrame.ZIndex = 0
chartDisplayFrame.Parent = screenGui

local judgmentLine = Instance.new("Frame")
judgmentLine.Name = "JudgmentLine"
judgmentLine.BackgroundColor3 = Color3.new(1, 1, 1)
judgmentLine.Size = UDim2.new(1, 0, 0, 4)
judgmentLine.Position = UDim2.new(0, 0, 1, -100)
judgmentLine.BorderSizePixel = 0
judgmentLine.Parent = chartDisplayFrame

-- === Variables and constants ===
local judgmentLineY = chartDisplayFrame.AbsoluteSize.Y - 100
local arrowSpeed = 200

local keyToDir = {
    Z = "left",
    X = "up",
    ["comma"] = "down",
    ["period"] = "right"
}

local arrowSymbols = {
    left = "←",
    up = "↑",
    down = "↓",
    right = "→"
}

local laneXPositions = {
    left = 80,
    down = 150,
    up = 220,
    right = 290,
}

local activeArrows = {}
local songStartTime = 0
local currentSong = nil
local connection

-- === Functions ===

local function parseFNFChart(fnfJson)
    local songData = fnfJson.song
    if not songData then
        warn("Invalid FNF JSON: missing 'song'")
        return nil
    end

    local bpm = songData.bpm or 120
    local speed = songData.speed or 1
    local notesSections = songData.notes
    if not notesSections then
        warn("Invalid FNF JSON: missing 'notes'")
        return nil
    end

    local secondsPerStep = (60 / bpm) / 4 -- 16th note duration
    local chart = {}
    local sectionStartTime = 0

    local noteDataToDir = {
        [0] = "left",
        [1] = "down",
        [2] = "up",
        [3] = "right"
    }

    for _, section in ipairs(notesSections) do
        local lengthInSteps = section.lengthInSteps or 16
        local sectionNotes = section.sectionNotes or {}

        for _, note in ipairs(sectionNotes) do
            local dir = noteDataToDir[note.noteData]
            if dir then
                local time = sectionStartTime + (note.noteTime or 0) * secondsPerStep / speed
                table.insert(chart, {
                    time = time,
                    dir = dir
                })
            end
        end

        sectionStartTime = sectionStartTime + (lengthInSteps * secondsPerStep) / speed
    end

    table.sort(chart, function(a,b) return a.time < b.time end)
    return chart
end

local function clearArrows()
    for _, arrow in pairs(activeArrows) do
        if arrow.UI then arrow.UI:Destroy() end
    end
    activeArrows = {}
end

local function startSong(song)
    clearArrows()

    currentSong = song
    songStartTime = tick()

    if connection then connection:Disconnect() end

    for _, note in ipairs(song.chart) do
        note.spawned = false
    end

    -- Hide the GUI box when song starts
    guiBox.Visible = false

    connection = RunService.Heartbeat:Connect(function()
        local elapsed = tick() - songStartTime

        -- Spawn arrows
        for _, note in ipairs(song.chart) do
            local spawnTime = note.time - ((chartDisplayFrame.AbsoluteSize.Y - judgmentLine.Position.Y.Offset) / arrowSpeed)
            if spawnTime <= elapsed and not note.spawned then
                note.spawned = true

                local arrowUI = Instance.new("TextLabel")
                arrowUI.Text = arrowSymbols[note.dir] or "?"
                arrowUI.Font = Enum.Font.SourceSansBold
                arrowUI.TextColor3 = Color3.new(1,1,1)
                arrowUI.BackgroundTransparency = 1
                arrowUI.Size = UDim2.new(0, 40, 0, 40)
                arrowUI.Position = UDim2.new(0, laneXPositions[note.dir], 0, chartDisplayFrame.AbsoluteSize.Y)
                arrowUI.ZIndex = 10
                arrowUI.Parent = chartDisplayFrame

                table.insert(activeArrows, {
                    UI = arrowUI,
                    dir = note.dir,
                    time = note.time,
                    hit = false,
                })
            end
        end

        -- Move arrows up
        for i = #activeArrows, 1, -1 do
            local arrow = activeArrows[i]
            if arrow.hit then
                arrow.UI:Destroy()
                table.remove(activeArrows, i)
            else
                local timeToJudgment = arrow.time - elapsed
                local yPos = judgmentLine.Position.Y.Offset + timeToJudgment * arrowSpeed

                if yPos < -40 then
                    -- Arrow missed, remove
                    arrow.UI:Destroy()
                    table.remove(activeArrows, i)
                else
                    arrow.UI.Position = UDim2.new(0, laneXPositions[arrow.dir], 0, yPos)
                end
            end
        end

        -- If no arrows left to spawn or active, song ended
        local allSpawned = true
        for _, note in ipairs(song.chart) do
            if not note.spawned then
                allSpawned = false
                break
            end
        end

        if allSpawned and #activeArrows == 0 then
            -- Song ended
            connection:Disconnect()
            connection = nil
            currentSong = nil
            -- Show GUI box again
            guiBox.Visible = true
        end
    end)
end

-- Hit arrows with keys
local hitWindow = 0.15

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local dir = keyToDir[input.KeyCode.Name]
    if dir and currentSong then
        local now = tick()
        local hitArrowIndex = nil
        for i, arrow in ipairs(activeArrows) do
            if not arrow.hit and arrow.dir == dir then
                local diff = math.abs(arrow.time - (now - songStartTime))
                if diff <= hitWindow then
                    hitArrowIndex = i
                    break
                end
            end
        end

        if hitArrowIndex then
            local arrow = activeArrows[hitArrowIndex]
            arrow.hit = true
            arrow.UI.TextColor3 = Color3.new(0,1,0)
        end
    end
end)

-- Drag logic for guiBox by dragBar
local dragging = false
local dragStart = nil
local startPos = nil

dragBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = guiBox.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

dragBar.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        guiBox.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Load button clicked
loadButton.MouseButton1Click:Connect(function()
    local success, result = pcall(function()
        return HttpService:JSONDecode(jsonInput.Text)
    end)

    if success and type(result) == "table" then
        local chart = parseFNFChart(result)
        if chart then
            local tempSong = {
                name = (result.song and result.song.song) or "Custom FNF Song",
                chart = chart
            }
            startSong(tempSong)
        else
            warn("Failed to parse FNF chart")
        end
    else
        warn("Failed to decode JSON")
    end
end)
