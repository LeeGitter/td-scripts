local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Animation
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://104113642912910"
local animTrack = humanoid:LoadAnimation(anim)
animTrack.Looped = true
animTrack:Play()
animTrack.Priority = Enum.AnimationPriority.Idle
animTrack:AdjustSpeed(1)

-- Float settings
local floatMin = 6
local floatMax = 7.5
local ascendHeight = 11
local ascendDuration = 1.5

-- States
local alive = true
local bounceTimer = 0
local isAscending = false
local ascendStartTime = 0

-- Disable on death
humanoid.Died:Connect(function()
	alive = false
end)

-- Disable unwanted states
humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)

-- Handle space to ascend
UIS.InputBegan:Connect(function(input, gpe)
	if gpe or input.KeyCode ~= Enum.KeyCode.Space or isAscending then return end

	isAscending = true
	ascendStartTime = tick()

	-- Force animation priority and speed
	animTrack:AdjustSpeed(3)
	animTrack.Priority = Enum.AnimationPriority.Action4
end)

-- Float + ascend loop
RunService.RenderStepped:Connect(function(dt)
	if not alive or not character or not character.Parent then return end

	local rootPos = hrp.Position
	local targetY

	if isAscending then
		local elapsed = tick() - ascendStartTime
		if elapsed < ascendDuration then
			targetY = ascendHeight
		else
			isAscending = false
			animTrack:AdjustSpeed(1)
			animTrack.Priority = Enum.AnimationPriority.Idle
		end
	else
		-- Bounce
		bounceTimer += dt * 2
		targetY = floatMin + math.sin(bounceTimer) * ((floatMax - floatMin) / 2)
	end

	-- Raycast to ground
	local rayOrigin = hrp.Position
	local rayDir = Vector3.new(0, -12, 0)
	local ray = Ray.new(rayOrigin, rayDir)
	local hit, groundPos = workspace:FindPartOnRay(ray, character)

	if hit then
		local desiredY = groundPos.Y + targetY
		local diff = desiredY - hrp.Position.Y
		hrp.Velocity = Vector3.new(hrp.Velocity.X, diff * 10, hrp.Velocity.Z)
	else
		-- Slow falling (1/3 normal)
		hrp.Velocity = Vector3.new(hrp.Velocity.X, math.max(hrp.Velocity.Y, -25) * 0.33, hrp.Velocity.Z)
	end
end)
