local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local active = false
local dummy = nil
local path = {}
local pathConnection = nil

-- Creates a glowing part for the path
local function createPathPoint(position)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 0.2, 1)
	part.Color = Color3.fromRGB(255, 255, 0)
	part.Material = Enum.Material.Neon
	part.CFrame = CFrame.new(position)
	part.Parent = workspace
	table.insert(path, part)
end

-- Spawns a basic R6 dummy under the player
local function spawnDummy(position)
	local dummy = Instance.new("Model")
	dummy.Name = "ControllableDummy"

	local function part(name, size, pos)
		local p = Instance.new("Part")
		p.Name = name
		p.Size = size
		p.Position = pos
		p.Anchored = false
		p.CanCollide = true
		p.TopSurface = Enum.SurfaceType.Smooth
		p.BottomSurface = Enum.SurfaceType.Smooth
		p.Parent = dummy
		return p
	end

	local root = part("HumanoidRootPart", Vector3.new(2, 2, 1), position)
	local torso = part("Torso", Vector3.new(2, 2, 1), position + Vector3.new(0, 1, 0))
	local head = part("Head", Vector3.new(2, 1, 1), position + Vector3.new(0, 3, 0))

	local weld1 = Instance.new("WeldConstraint", torso)
	weld1.Part0 = torso
	weld1.Part1 = root

	local weld2 = Instance.new("WeldConstraint", torso)
	weld2.Part0 = torso
	weld2.Part1 = head

	local humanoid = Instance.new("Humanoid")
	humanoid.Parent = dummy

	dummy.PrimaryPart = root
	dummy:SetPrimaryPartCFrame(CFrame.new(position))
	dummy.Parent = workspace

	return dummy
end

-- Start control mode
local function beginControl()
	active = true
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:WaitForChild("Humanoid")

	-- Float player
	hrp.Anchored = true
	hrp.CFrame += Vector3.new(0, 10, 0)

	-- Spawn dummy under player
	dummy = spawnDummy(hrp.Position - Vector3.new(0, 3, 0))
	local dummyHumanoid = dummy:WaitForChild("Humanoid")

	-- Camera follows dummy
	camera.CameraSubject = dummyHumanoid

	-- Movement path tracker
	local lastPos = dummy.PrimaryPart.Position
	pathConnection = RunService.Heartbeat:Connect(function()
		local pos = dummy.PrimaryPart.Position
		if (pos - lastPos).Magnitude >= 2 then
			createPathPoint(pos)
			lastPos = pos
		end
	end)
end

-- End control mode
local function endControl()
	active = false

	-- Stop tracking
	if pathConnection then
		pathConnection:Disconnect()
		pathConnection = nil
	end

	-- Delete dummy
	if dummy then
		dummy:Destroy()
		dummy = nil
	end

	-- Reset camera and un-anchor player
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:WaitForChild("Humanoid")

	hrp.Anchored = false
	camera.CameraSubject = humanoid

	-- Follow the path
	coroutine.wrap(function()
		for _, p in ipairs(path) do
			local goal = p.Position + Vector3.new(0, 1, 0)
			local dist = (hrp.Position - goal).Magnitude
			local tween = TweenService:Create(hrp, TweenInfo.new(dist / 16, Enum.EasingStyle.Linear), {
				CFrame = CFrame.new(goal)
			})
			tween:Play()
			tween.Completed:Wait()
		end

		-- Cleanup path
		for _, p in ipairs(path) do
			p:Destroy()
		end
		table.clear(path)
	end)()
end

-- Toggle with T key
UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.T then
		if not active then
			beginControl()
		else
			endControl()
		end
	end
end)
