local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local active = false
local dummy = nil
local path = {}
local pathConnection = nil
local moveConnection = nil
local walkConnection = nil

-- Create glowing path part
local function createPathPoint(position)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 0.2, 1)
	part.Color = Color3.fromRGB(255, 255, 0)
	part.Material = Enum.Material.Neon
	part.CFrame = CFrame.new(position)
	part.Parent = workspace
	table.insert(path, part)
end

-- Spawn R6 dummy clone
local function spawnDummy(position)
	local desc = Players:GetHumanoidDescriptionFromUserId(player.UserId)
	local model = Players:CreateHumanoidModelFromDescription(desc, Enum.HumanoidRigType.R6)
	model.Name = "ControllableClone"

	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Transparency = 0.5
			part.Color = Color3.fromRGB(255, 0, 0)
			part.Material = Enum.Material.ForceField
		end
	end

	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.Transparency = 1
		hrp.CanCollide = false
		hrp.CFrame = CFrame.new(position)
	end

	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.WalkSpeed = 50
	end

	model.Parent = workspace
	return model
end

-- Start controlling clone
local function beginControl()
	active = true

	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")

	-- FLOAT 4 studs upward
	hrp.Anchored = true
	hrp.CFrame += Vector3.new(0, 4, 0)

	dummy = spawnDummy(hrp.Position - Vector3.new(0, 4, 0))
	local dummyHumanoid = dummy:FindFirstChildOfClass("Humanoid")
	camera.CameraSubject = dummyHumanoid

	-- Movement control with upward float on Space
	moveConnection = RunService.RenderStepped:Connect(function()
		if not dummy or not dummy:FindFirstChild("HumanoidRootPart") then return end

		local moveVec = Vector3.zero
		if UIS:IsKeyDown(Enum.KeyCode.W) then moveVec += Vector3.new(0, 0, 1) end
		if UIS:IsKeyDown(Enum.KeyCode.S) then moveVec += Vector3.new(0, 0, -1) end
		if UIS:IsKeyDown(Enum.KeyCode.A) then moveVec += Vector3.new(-1, 0, 0) end
		if UIS:IsKeyDown(Enum.KeyCode.D) then moveVec += Vector3.new(1, 0, 0) end

		local root = dummy:FindFirstChild("HumanoidRootPart")
		if not root then return end

		-- Handle horizontal movement
		if moveVec.Magnitude > 0 then
			local camCF = camera.CFrame
			local forward = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z).Unit
			local right = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z).Unit
			local moveDir = (right * moveVec.X + forward * moveVec.Z).Unit
			if dummyHumanoid then
				dummyHumanoid:Move(moveDir, false)
			end
			root.CFrame = CFrame.new(root.Position, root.Position + moveDir)
		else
			if dummyHumanoid then
				dummyHumanoid:Move(Vector3.zero, false)
			end
		end

		-- Handle upward floating on Space key
		if UIS:IsKeyDown(Enum.KeyCode.Space) then
			-- Float upward slowly, e.g., 0.1 studs per frame
			root.CFrame = root.CFrame + Vector3.new(0, 0.1, 0)
		end
	end)

	-- Record movement path
	local lastPos = dummy.HumanoidRootPart.Position
	pathConnection = RunService.Heartbeat:Connect(function()
		local root = dummy:FindFirstChild("HumanoidRootPart")
		if root and (root.Position - lastPos).Magnitude >= 2 then
			createPathPoint(root.Position)
			lastPos = root.Position
		end
	end)
end

-- Walk the path with smooth acceleration and no jitter
local function walkPath()
	local char = player.Character or player.CharacterAdded:Wait()
	local humanoid = char:WaitForChild("Humanoid")
	local hrp = char:WaitForChild("HumanoidRootPart")

	hrp.Anchored = false
	camera.CameraSubject = humanoid
	humanoid.AutoRotate = false

	if #path == 0 then return end

	local points = {hrp.Position}
	for _, p in ipairs(path) do
		table.insert(points, p.Position)
	end

	local distances = {0}
	for i = 2, #points do
		local dist = (points[i] - points[i - 1]).Magnitude
		distances[i] = distances[i - 1] + dist
	end

	local totalLength = distances[#distances]
	if totalLength == 0 then return end

	local timeLimit = 5 -- Adjust this to control total path walk time
	local elapsed = 0

	local function accelerationCurve(t)
		return t * t
	end

	if walkConnection then
		walkConnection:Disconnect()
		walkConnection = nil
	end

	local lastCFrame = hrp.CFrame

	walkConnection = RunService.RenderStepped:Connect(function(dt)
		elapsed += dt
		local t = math.clamp(elapsed / timeLimit, 0, 1)
		local speedFactor = accelerationCurve(t)

		local targetDistance = speedFactor * totalLength

		local segmentIndex = 1
		while segmentIndex < #distances and distances[segmentIndex + 1] < targetDistance do
			segmentIndex += 1
		end

		local segmentStartDist = distances[segmentIndex]
		local segmentEndDist = distances[segmentIndex + 1]
		local segmentLength = segmentEndDist - segmentStartDist
		local alpha = 0
		if segmentLength > 0 then
			alpha = (targetDistance - segmentStartDist) / segmentLength
		end

		local startPos = points[segmentIndex]
		local endPos = points[segmentIndex + 1]
		local newPos = startPos:Lerp(endPos, alpha)

		local lookDir = (endPos - startPos).Unit
		local desiredCFrame = CFrame.new(newPos, newPos + lookDir)
		local smoothCFrame = lastCFrame:Lerp(desiredCFrame, 0.3)
		hrp.CFrame = smoothCFrame
		lastCFrame = smoothCFrame

		if t >= 1 then
			walkConnection:Disconnect()
			walkConnection = nil
			for _, p in path do p:Destroy() end
			table.clear(path)
			humanoid.AutoRotate = true
		end
	end)
end

-- End control, cleanup, start walking
local function endControl()
	active = false

	if pathConnection then
		pathConnection:Disconnect()
		pathConnection = nil
	end
	if moveConnection then
		moveConnection:Disconnect()
		moveConnection = nil
	end
	if dummy then
		dummy:Destroy()
		dummy = nil
	end

	local char = player.Character or player.CharacterAdded:Wait()
	char:WaitForChild("HumanoidRootPart").Anchored = false

	walkPath()
end

-- Toggle with T
UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.T then
		if not active then
			beginControl()
		else
			endControl()
		end
	end
end)
