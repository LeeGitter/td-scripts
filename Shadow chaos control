local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local active = false
local dummy = nil
local path = {}
local pathConnection = nil
local moveConnection = nil

local cloneSpawnPosition = nil

-- Create glowing path part
local function createPathPoint(position)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 0.2, 1)
	part.Color = Color3.fromRGB(255, 255, 0)
	part.Material = Enum.Material.Neon
	part.CFrame = CFrame.new(position)
	part.Parent = workspace
	table.insert(path, part)
end

-- Spawn invisible dummy
local function spawnDummy(position)
	local desc = Players:GetHumanoidDescriptionFromUserId(player.UserId)
	local model = Players:CreateHumanoidModelFromDescription(desc, Enum.HumanoidRigType.R6)

	model.Name = "ControllableClone"

	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Transparency = 1
			part.CanCollide = false
			part.Material = Enum.Material.SmoothPlastic
		end
	end

	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.Transparency = 1
		hrp.CanCollide = false
		for _, child in hrp:GetChildren() do
			if child:IsA("Decal") or child:IsA("Mesh") or child:IsA("Attachment") then
				child:Destroy()
			end
		end
		hrp.CFrame = CFrame.new(position)
	end

	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.WalkSpeed = 50
	end

	model.Parent = workspace
	return model
end

-- Begin control phase (float + dummy control)
local function beginControl()
	active = true

	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:WaitForChild("Humanoid")

	-- Disable player control and physics
	humanoid.PlatformStand = true

	-- Float gently with BodyVelocity
	local bodyVel = Instance.new("BodyVelocity")
	bodyVel.Name = "FloatBodyVelocity"
	bodyVel.MaxForce = Vector3.new(0, math.huge, 0)
	bodyVel.Velocity = Vector3.new(0, 5, 0)
	bodyVel.Parent = hrp

	-- Spawn dummy and set camera
	cloneSpawnPosition = hrp.Position - Vector3.new(0, 4, 0)
	dummy = spawnDummy(cloneSpawnPosition)
	local dummyHumanoid = dummy:FindFirstChildOfClass("Humanoid")
	camera.CameraSubject = dummyHumanoid

	-- Movement handling for dummy
	moveConnection = RunService.RenderStepped:Connect(function()
		if not dummy or not dummy:FindFirstChild("HumanoidRootPart") then return end

		local moveVec = Vector3.zero
		if UIS:IsKeyDown(Enum.KeyCode.W) then moveVec += Vector3.new(0, 0, 1) end
		if UIS:IsKeyDown(Enum.KeyCode.S) then moveVec += Vector3.new(0, 0, -1) end
		if UIS:IsKeyDown(Enum.KeyCode.A) then moveVec += Vector3.new(-1, 0, 0) end
		if UIS:IsKeyDown(Enum.KeyCode.D) then moveVec += Vector3.new(1, 0, 0) end

		if moveVec.Magnitude > 0 then
			local camCF = camera.CFrame
			local forward = camCF.LookVector * Vector3.new(1, 0, 1)
			local right = camCF.RightVector * Vector3.new(1, 0, 1)
			local moveDir = (right * moveVec.X + forward * moveVec.Z).Unit

			local root = dummy:FindFirstChild("HumanoidRootPart")
			if root then
				local proposedPos = root.Position + moveDir * dummy:FindFirstChildOfClass("Humanoid").WalkSpeed * RunService.RenderStepped:Wait()
				if (proposedPos - cloneSpawnPosition).Magnitude <= 200 then
					dummy:FindFirstChildOfClass("Humanoid"):Move(moveDir, false)
					root.CFrame = CFrame.new(root.Position, root.Position + moveDir)
				else
					dummy:FindFirstChildOfClass("Humanoid"):Move(Vector3.zero, false)
				end
			end
		else
			dummy:FindFirstChildOfClass("Humanoid"):Move(Vector3.zero, false)
		end
	end)

	-- Path tracking
	local lastPos = dummy.HumanoidRootPart.Position
	pathConnection = RunService.Heartbeat:Connect(function()
		local root = dummy:FindFirstChild("HumanoidRootPart")
		if root and (root.Position - lastPos).Magnitude >= 2 then
			createPathPoint(root.Position)
			lastPos = root.Position
		end
	end)
end

-- End control and begin walking path
local function endControl()
	active = false

	if pathConnection then pathConnection:Disconnect() end
	if moveConnection then moveConnection:Disconnect() end
	if dummy then dummy:Destroy() end

	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:WaitForChild("Humanoid")

	-- Remove BodyVelocity and restore control
	local bodyVel = hrp:FindFirstChild("FloatBodyVelocity")
	if bodyVel then
		bodyVel:Destroy()
	end

	humanoid.PlatformStand = false
	camera.CameraSubject = humanoid

	if #path == 0 then
		return
	end

	-- Calculate total distance for path
	local totalDist = 0
	for i = 2, #path do
		totalDist += (path[i].Position - path[i-1].Position).Magnitude
	end

	if totalDist == 0 then
		for _, p in path do p:Destroy() end
		table.clear(path)
		return
	end

	local maxTime = 8
	local startSpeed = 8
	local maxSpeed = math.max(16, totalDist / maxTime)
	local elapsed = 0

	-- Ensure humanoid is not moving before start
	humanoid:Move(Vector3.new(0, 0, 0), false)
	humanoid.WalkSpeed = startSpeed

	for i = 1, #path do
		local targetPos = path[i].Position + Vector3.new(0, 1, 0)

		while (hrp.Position - targetPos).Magnitude > 1 do
			local currentSpeed = math.min(startSpeed + ((maxSpeed - startSpeed) * (elapsed / maxTime)), maxSpeed)
			humanoid.WalkSpeed = currentSpeed

			local direction = (targetPos - hrp.Position).Unit
			humanoid:Move(direction, false)

			wait(0.03)
			elapsed = math.min(elapsed + 0.03, maxTime)
		end

		humanoid:Move(Vector3.new(0, 0, 0), false)
		wait(0.05)
	end

	humanoid.WalkSpeed = 16
	humanoid:Move(Vector3.new(0, 0, 0), false)

	for _, p in path do p:Destroy() end
	table.clear(path)
end

UIS.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.T then
		if not active then
			beginControl()
		else
			endControl()
		end
	end
end)
