local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local root = character:WaitForChild("HumanoidRootPart")

-- Constants
local DASH_ANIMATION_ID = "rbxassetid://135934693058362"
local NORMAL_SPEED = 25
local DASH_SPEED = 75
local ACCEL_DURATION = 2
local DASH_DURATION = 3

-- State
local isCharging = false
local isReadyToRelease = false
local isDashing = false
local animationTrack

-- Load animation
local dashAnim = Instance.new("Animation")
dashAnim.AnimationId = DASH_ANIMATION_ID

local function freezeCharacter()
	humanoid.AutoRotate = false
	humanoid.WalkSpeed = 0
	root.AssemblyLinearVelocity = Vector3.zero
end

local function unfreezeCharacter()
	humanoid.AutoRotate = true
	humanoid.WalkSpeed = NORMAL_SPEED
end

-- Handle Dash Start
local function startDashMode()
	isCharging = false
	isReadyToRelease = false
	isDashing = true

	if animationTrack then
		animationTrack:Stop()
	end

	-- Accelerate forward
	local t0 = tick()
	local accelConnection
	accelConnection = RunService.RenderStepped:Connect(function()
		local t = tick() - t0
		if t <= ACCEL_DURATION then
			local progress = math.clamp(t / ACCEL_DURATION, 0, 1)
			local speed = DASH_SPEED * progress
			local dir = workspace.CurrentCamera.CFrame.LookVector
			root.AssemblyLinearVelocity = dir * speed
		else
			accelConnection:Disconnect()
		end
	end)

	task.wait(ACCEL_DURATION)

	humanoid.WalkSpeed = DASH_SPEED
	humanoid.AutoRotate = false

	local moveConnection
	moveConnection = RunService.RenderStepped:Connect(function()
		if not isDashing then
			moveConnection:Disconnect()
			return
		end

		local inputVector = Vector3.zero
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then inputVector += Vector3.new(0, 0, -1) end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then inputVector += Vector3.new(0, 0, 1) end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then inputVector += Vector3.new(-1, 0, 0) end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then inputVector += Vector3.new(1, 0, 0) end

		if inputVector.Magnitude > 0 then
			local cam = workspace.CurrentCamera.CFrame
			local flatLook = Vector3.new(cam.LookVector.X, 0, cam.LookVector.Z).Unit
			local flatRight = Vector3.new(cam.RightVector.X, 0, cam.RightVector.Z).Unit
			local moveDir = (flatRight * inputVector.X + flatLook * inputVector.Z).Unit

			local currentVel = root.AssemblyLinearVelocity
			local forward = currentVel.Magnitude > 0 and currentVel.Unit or moveDir
			local blended = forward:Lerp(moveDir, 0.05) * DASH_SPEED

			root.AssemblyLinearVelocity = blended
			root.CFrame = CFrame.new(root.Position, root.Position + blended)
		end
	end)

	task.wait(DASH_DURATION)
	isDashing = false
	unfreezeCharacter()
end

-- Handle T Press (start charge & animation)
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.T and not isCharging and not isDashing then
		isCharging = true
		isReadyToRelease = false
		freezeCharacter()

		-- Play animation
		if animationTrack then animationTrack:Stop() end
		animationTrack = humanoid:LoadAnimation(dashAnim)
		animationTrack:Play()
		animationTrack:AdjustSpeed(1)

		-- Ramp up animation speed over 2 seconds
		local t0 = tick()
		RunService.RenderStepped:Connect(function()
			if not isCharging then return end
			local elapsed = tick() - t0
			if elapsed >= ACCEL_DURATION then
				animationTrack:AdjustSpeed(3)
				isReadyToRelease = true
				return
			end
			local speed = 1 + 2 * (elapsed / ACCEL_DURATION)
			animationTrack:AdjustSpeed(speed)
		end)
	end
end)

-- Handle T Release (only after speed is 3x)
UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.T and isCharging and isReadyToRelease then
		startDashMode()
	end
end)
